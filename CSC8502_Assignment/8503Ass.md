# CSC8503 Coursework: Real Time Game Technologies Demo

Module Leader: Rich Davison · Contact: [Richard-Gordon.Davison@newcastle.ac.uk](mailto:Richard-Gordon.Davison@newcastle.ac.uk) 

This page has been aligned to the University’s Assessment, Feedback and Marking Policy (effective 2025). The brief, submission rules, AI expectations, and feedback timelines are explicitly stated below. The essence, tasks, marking scheme, learning outcomes, and dates are unchanged.

## **Assessment Brief**

In this coursework you are to develop a game that includes physics, networking, and AI, to allow you to practice your coding skills, and reinforce your knowledge in these areas. The game takes place in a simple 3D environment, where the player controls an avatar using physics calculations, and must employ collision detection and resolution.

The codebase you have been provided with serves as a good starting point for the development of your game. The goal of the coursework is to then enhance this codebase with realistic physics and collisions, to allow the basics of the game to be played. From there, AI techniques can be used to add in some more complex movements of enemies that the player must interact with. You do not need to spend any time implementing graphical techniques, or finding new meshes and textures to apply to your game - the purpose of this coursework is just to investigate the new concepts introduced in the lectures and tutorials.

The coursework is divided into two parts. The first will primarily cover physics calculations and simple state machines, while the second covers networking and pathfinding. While the exact game implementation is up to you, the following video should provide some inspiration as to what could be replicated in your program: [https://www.youtube.com/watch?v=W3L5ifvKgxULinks to an external site.](https://www.youtube.com/watch?v=W3L5ifvKgxU)

**Coursework Part A: No Pane, No Game**

It is a hard life being a courier! You have been tasked with taking some precious, easily breakable items to their destinations, in a world filled with hazards and puzzles. Dropping or otherwise breaking the items will result in being fired from your job. To make matters worse, the local streets are littered with obstacles and mischievous characters who intend on making your life difficult. The player object should be controlled with the keyboard and mouse, via the application of forces or impulses. You may choose to apply torque to rotate the player object, or use functions to automatically change its orientation to the desired direction. Players can earn points by solving puzzles, and getting items from the starting position to the end zone without breaking them. 

If the player successfully delivers all of the items, or the time runs out, then the game will game end, and the player is shown their final score. The game should feature a simple menu, allowing the player to play again, or exit the game. During the game, the player’s current score, and number of items left to deliver should be displayed on screen.

The game you create should take place within a single virtual environment - the exact composition of this is up to you, but it should have obstacles placed around (built using a combination of any collision detection and resolution types that you can create) to make the world more interesting. The level should contain a number of simple challenges that the player must complete to open paths to the end zone. Pushing an item onto a button to open a door, or navigating a set of narrow platforms to find a key would be examples of these challenges. The level should also have a number of enemy AI characters. These characters should patrol the world – if the player comes near them, they should chase the player who will ‘die’ if the AI reaches them, causing them to reset back to their initial position. There should be some usage of raycasting within the world. This can be to help the player in some way (maybe the player can find a grappling hook powerup?), or it could be used as part of the AI (perhaps the enemy AI speeds up if it can see the player?).

**Coursework Part B: Borosilicate Buddies**

Everyone knows games are more fun with multiple players! The game should be expanded to include a networked multiplayer component. In this game mode, two players must work together to carry a particularly heavy item from the starting point to the end zone. The game environment should be adjusted accordingly. The players can only move the item if they are both carrying it. A player can choose to stop carrying the item temporarily (e.g. in order to complete a puzzle), but in such situations the other player cannot move.

The menu should be expanded to allow the creation of a server, or for connecting to an already running server by IP. The server should maintain a high-score table of best point totals achieved during gameplay – this should be updated and sent as appropriate to connecting players so that it can be viewed by pressing a key.

The game should also feature an expanded area containing new NPC characters. Somewhere in the game environment there should be a hedge maze, patrolled by an angry goose, who particularly dislikes couriers carrying easily breakable items.  There is also a rival courier, who will intelligently travel the game world looking for items to throw stones at. Both new AI opponents should be controlled by the server.

## **Deliverable Items – NESS Submission**

1. Source code and clean Visual Studio solution. Zip your work folder, minus the .vs and .git folders, if present.
2. A document containing at least four screenshots with descriptions, a list of any key/mouse presses that perform actions, and a link to a YouTube video of your coursework running.

## **Marks Available (100)**

### Coursework Part A (50 marks)

- Implementation of the standard features gains up to 50 marks.
- A “first class” submission consists of these features implemented with well-structured code, running at 60fps in full screen on the lab PC.

### Coursework Part B (50 marks)

- Implementations of advanced rendering techniques (including, but not limited to, the features described above) gain up to 50 marks.
- A “first class” submission entails a balanced scene of graphical effects including at least four advanced graphical features (well implemented and integrated with the standard features), running at a minimum of 60fps in full-screen mode. The code should be clearly formatted.

### **Contacts**

Rich Davison · Contact: [Richard-Gordon.Davison@newcastle.ac.uk](mailto:Richard-Gordon.Davison@newcastle.ac.uk) 

Gary Ushaw - Contact: [gary.ushaw@newcastle.ac.uk](mailto:gary.ushaw@newcastle.ac.uk) 

Technical issues: IT Service Desk ([it.servicedesk@ncl.ac.uk](mailto:it.servicedesk@ncl.ac.uk)).

### **Policies**

Students are reminded of Newcastle University regulations concerning [Student ProgressLinks to an external site.](https://go.ncl.ac.uk/canvas/assessment/studentprogress) and [Plagiarism.Links to an external site.](https://go.ncl.ac.uk/canvas/assessment/plagiarism). 

Up until the submission deadline your assignment may be submitted. 

Re-submission is possible until the deadline. Your last submission before the deadline will be assessed to determine your mark and referred to when providing feedback. The date/time of your last submission will also be used to verify whether your submission is on time.

Submissions made after the deadline will be identified as late and penalised. The University’s Policy on Assessment and Feedback outlines that work submitted after the deadline will be capped according to a [sliding scaleLinks to an external site.](https://go.ncl.ac.uk/canvas/assessment/policy)

### **Submitting Your Work**

Submit a zip file containing the project, and a link to a video of the demo (eg on YouTube)

Upload to NESS before the published deadline. Demonstrations will take place in the scheduled lab session

### **Feedback**

- Written feedback and provisional marks will be released in NESS within **20 working days** of the submission deadline.
- Verbal feedback will be given during the marking session
- Comments will indicate concrete improvements for future assessments.

### **Expectations for the use of AI** 

AI tools can assist with reasoning, code exploration, and project management. Your work must always reflect your own understanding.

### Permitted

- Brainstorming approaches or recalling API usage.
- Language polishing in documentation or design rationale.
- Code management activities such as refactoring, repository organisation, and documentation.
- Acknowledging AI use in comments or design rationale.

### Not permitted

- End-to-end AI-generated solutions or code you cannot explain in viva.
- Uploading University or peers’ work to third-party tools in violation of data policies.
- Using AI “detectors” as evidence. Misconduct is handled via University procedure.

## **Learning Outcomes**

- The ability to describe:  
    • Physics and real-time algorithms mathematically.  
    • Real-time collision detection algorithms mathematically.  
    • Real-time artificial intelligence for computer simulations mathematically.  
    • Combine all material taught into a single simulation.  
    • Combine physics and real-time collision detection to simulate solid body interaction.