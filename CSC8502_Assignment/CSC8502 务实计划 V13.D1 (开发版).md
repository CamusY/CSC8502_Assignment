## 1. 背景与目标

### 1.1 项目背景

本项目是纽卡斯尔大学 CSC8502 课程的最终考核。要求使用 C++ 和 OpenGL 开发一个实时图形 Demo，核心主题是“两个不同时间周期之间的场景过渡”。

### 1.2 核心挑战：“系统隔离与务实耦合”

在确认了项目**必须**基于学校提供的 `nclgl` 框架（或完全自研）后，架构的核心挑战被重新定义为：**在务实地接受 `nclgl` 耦合的前提下，实现最大限度的系统隔离。**

V11 计划中“可演化架构” 的目标（特别是数学库的平滑替换）被证明是过度设计，且与项目（交付 Demo）的短期目标相悖。

V13 计划的核心架构决策是：

1. **接受耦合 (数据层)：** 我们将**完全接受 `nclgl` 的数学库**（`Vector3`, `Matrix4` 等）作为整个项目的**“通用数学语言 (Common Math Language)”**。这是一种有意识的架构妥协，我们接受 `IAL` 接口层与 `nclgl` 数学库的实现永久绑定的风险。
    
2. **隔离系统 (服务层)：** 我们将**严格隔离**所有非数学的、有状态的、复杂的**“系统”**（如 `OGLRenderer`, `Mesh`, `Shader`, `Window`, 资源加载）。
    

“双轨制” 依然有效，但其定义被修正为：

- **轨道 B (基线):**`nclgl` 实现。一个实现了所有“服务接口 (IAL)”的“胶水层”，其内部封装了 `nclgl` 的 `Mesh`, `Shader` 等具体类，**并利用 `nclgl/Extra/GLTFLoader.h` 来实现对 `.gltf` 格式的支持**。
    
- **轨道 C (演化):** 自研实现。一个**同样**实现了所有“服务接口 (IAL)”的、功能对等的自研代码库。
    

此架构放弃了替换数学库的灵活性，以换取当前开发的高效性、零抽象开销和对系统级（Renderer, Factory 等）模块的完全演化能力。

### 1.3 术语定义

为避免混淆，本文档明确以下术语：

- **服务接口 (Service IAL):** 一组用于“服务”型或“对象”型功能的、100% 纯净的 C++ **纯虚接口**（位于 `src/Engine/IAL/` 目录），例如 `I_ResourceFactory`, `I_WindowSystem`, `I_Mesh`。
    
- **通用数学库 (Common Math Library):** 特指 `nclgl` 提供的数学类型（`Vector3.h`, `Matrix4.h`, `Quaternion.h` 等）。这些**不是**接口，而是被整个架构（包括 `IAL` 和 `Demo` 层）所**直接依赖**的具体实现。
    
- **轨道 B (nclgl) / 轨道 C (Custom):** 指 `IAL` 接口的两个不同实现集合。轨道 B 默认使用 `nclgl`，轨道 C 使用自研代码。
    
- **Part A / B (部分 A / B):** 指课程大纲 中的**功能要求**。Part A 为基础功能（如过渡），Part B 为高级功能（如阴影）。
	
- **逻辑命名空间 `nclgl::` :** 本文档在提及学校提供的库类时，可能会使用 `nclgl::` 前缀（例如 `nclgl::Window`, `nclgl::Vector3`）以示区分。**务必注意：** 在实际的 C++ 代码中，`nclgl` 库并没有使用命名空间，所有类均位于**全局命名空间**中（例如应在代码中使用 `::Window` 或 `Window`）。

_(V11 中的“适配器层 (Adapter Layer)” 术语已被废除，因其引入了不必要的抽象层)。_

### 1.4 架构目标 (接口驱动架构)

本计划的架构目标被重新定义为“接口驱动架构”。此架构的核心是采用一个严格的纯虚接口模型，以隔离所有系统级的实现细节。

1. **建立统一抽象层:** 架构分为两个部分：
    
    - **通用数据类型 (耦合):** 对于数学库（`Vector3`, `Matrix4`, `Quaternion`），核心引擎代码（`CSC8502_Assignment/`）将**直接 `#include "nclgl/Vector3.h"`** 并使用其具体类型。**不存在**任何包装器或适配器。
        
    - **系统接口 (隔离):** 对于所有其他 `nclgl` “服务”型（如资源加载、**窗口系统、输入处理**）或“对象”型（如 `Mesh`, `Shader`）的类，我们将建立一组 100% 纯净的 C++ **纯虚接口**（位于 `Engine/IAL/` 目录）。这些接口的函数签名将**直接使用** `nclgl` 的数学类型（例如 `virtual void DrawLine(const Vector3& start, ...)`）。
        
2. **隔离引擎核心:** 核心引擎与游戏逻辑代码（位于 `src/CSC8502_Assignment/` 目录）**只**依赖于 `IAL/` 纯虚接口和 `nclgl/` 通用数学库。
    
3. **命名空间:** `IAL` 接口（如 `I_Mesh`）应定义在统一的命名空间（例如 `Engine::IAL`）下。`nclgl` 的数学库（如 `Vector3`）将按其原始定义，在全局命名空间 (`::Vector3`) 中使用，我们接受这种耦合。
    
4. **宏驱动的双轨切换：** 仅在 `main.cpp` 的**服务注入（DI）**层使用宏切换 `B_` vs `C_` 实现。**场景层不再使用任何宏进行资源路径切换，统一加载 `.gltf` 资源（见 NFR-4）。**
    
5. **简化构建:** 构建系统（VS2022） 的职责被极大简化。它不再需要 `if/else` 逻辑，只需编译**所有**源文件（`nclgl`, `Custom`, `Engine`, `CSC8502_Assignment`）并将其链接在一起。
    
6. **明确演化路径:** “轨道 C”（自研）是一个完整的实现目标，它必须包括自研的网格加载器（支持 `.gltf`）、骨骼动画系统等，以**实现** `IAL/` 接口。轨道 C 的实现**也必须**使用 `nclgl` 数学库作为其接口的“通用语言”。
    

此架构的**衡量标准**是：核心渲染逻辑（`Renderer.cpp`）在不修改一行代码的前提下，可以通过**修改 `main.cpp` 中的宏定义**并重新编译，来无缝切换 `IAL` 接口的 `nclgl` 实现（轨道 B）和 `Custom` 自研实现（轨道 C）。游戏场景层（`Scene_T1_Peace.cpp`）的代码将依赖此宏来加载正确的资源。

## 2. 需求说明 (功能性)

根据课程大纲，项目必须满足以下功能：

| **ID** | **类别** | **需求描述**                                                                        | **来源 (8502.pdf)** |
| ------ | ------ | ------------------------------------------------------------------------------- | ----------------- |
| P-0    | 基础     | (渲染) 渲染一个包含天空盒、水体、地形的 3D 场景。                                                    |                   |
| P-1    | 核心     | (过渡) 场景必须在两个不同的时间周期 (T1, T2) 之间过渡。                                              |                   |
| P-2    | 核心     | (识别性) T2 场景必须**可被识别**为 T1 场景在不同时间的样子（例如，和平时期 vs 战后废墟）。                          |                   |
| P-3    | 核心     | (效果) T1 到 T2 的过渡必须通过一个**全屏后期处理效果**来表现。                                          |                   |
| P-4    | 高级     | (Part B) 实现至少两个高级图形特性（例如：**阴影**、**骨骼动画**、复杂后期处理 等）。                             |                   |
| P-5    | 核心     | (交互) 1. 相机必须能自动**沿预设轨迹（Track）**运行。2. **按下特定按键**后，必须切换到“自由”相机。3. 提供可通过 UI 调控的参数。 |                   |
| P-6    | 核心     | (管理) 必须有合理的场景管理结构（**自研的场景图系统**）。                                                |                   |
| P-7    | 核心     | (光照) 场景中必须包含基础光照（环境、漫反射、高光）。将使用 Blinn-Phong 模型实现。                               |                   |
| P-8    | 核心     | (天空盒) 必须实现天空盒（环境映射）。                                                            |                   |

## 3. 需求说明 (非功能性 - 架构)

| **ID**                    | **类别**            | **需求描述**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ------------------------- | ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| NFR-1                     | **系统解耦 (核心)**     | 位于 `src/CSC8502_Assignment/` 目录下的所有 `.cpp` 和 `.h` 文件，**严禁**出现以下 `include` 语句：<br><br>  <br>  <br><br>`"#include "nclgl/Mesh.h"`<br><br>  <br><br>`"#include "nclgl/Shader.h"`<br><br>  <br><br>`"#include "nclgl/OGLRenderer.h"`<br><br>  <br><br>`"#include "nclgl/Window.h"`<br><br>  <br><br>`"#include "nclgl/Keyboard.h"`<br><br>  <br><br>`"#include "nclgl/Mouse.h"`<br><br>  <br>  <br><br>(或任何 `nclgl` 库中**非**数学库的系统级头文件)。<br><br>  <br>  <br><br>**例外：**<br><br>  <br><br>1. `src/CSC8502_Assignment/main.cpp` (NFR-9 定义的依赖注入点)。<br><br>  <br><br>2. `src/CSC8502_Assignment/Game/Scenes/` 下的场景文件（NFR-4 定义的资源选择点）。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| NFR-2                     | **依赖抽象层**         | `src/CSC8502_Assignment/` 的代码**必须且只能**依赖两类头文件：<br><br>  <br>  <br><br>1. **系统接口:** `Engine/IAL/` 目录下的纯虚接口 (例如 `"IAL/I_Resource.h"`, `"IAL/I_WindowSystem.h"`)。<br><br>  <br><br>2. **通用数学库:** `nclgl/` 目录下的数学库 (例如 `"nclgl/Vector3.h"`, `"nclgl/Matrix4.h"`)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| NFR-3                     | **双轨实现**          | 必须提供两套完整的实现：<br><br> 1. **轨道 B (基线):** 位于 `Engine/Implementations/NCLGL_Impl/`，完全基于 `nclgl` 库实现所有 `IAL` 接口。**利用 `nclgl` 库内置的 `GLTFLoader`，原生支持 `.gltf` 格式的模型、材质和骨骼动画**。<br><br> 2. **轨道 C (演化):** 位于 `Engine/Implementations/Custom/`（及 `Engine/Custom/`），提供所有 `IAL` 接口的**自研**实现。**目标同样是**支持 `.gltf` 模型和动画。<br><br> 两套实现都**必须**使用 `nclgl` 数学库作为其 `IAL` 接口的公共数据类型。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| NFR-4                     | **预处理器切换**        | 架构切换逻辑**严禁**使用 CMake `if/else` 或其他构建系统逻辑在编译时切换链接的 `.cpp` 文件。<br><br>切换**必须**通过 C++ 预处理器宏（例如 `#ifdef NCL_USE_CUSTOM_IMPL`）在**一个**层级实现：<br><br> 1. **服务注入 (DI):** 在 `src/CSC8502_Assignment/main.cpp` 中切换 `IAL` 接口的具体实现（例如 `B_Factory` vs `C_Factory`）。<br><br> 2. **<del>资源选择:</del>** <ins>（此条已废除）</ins>。由于轨道 B 和轨道 C 现在都支持 `.gltf` 格式，`Game/Scenes/` 层的代码**无需**使用宏进行资源路径切换，应统一加载 `.gltf` 资源。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| NFR-5                     | **性能**            | 实时渲染必须保持在可接受的帧率。课程大纲要求“first class”提交在 lab PC 上达到 60fps。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| NFR-6                     | **资源共享**          | 两套实现应尽可能使用相同的资源文件。着色器 (GLSL) 文件**必须**共享，并统一存放于 `Assets/Shaders/Shared/` 目录。高度图、纹理等也应尽可能共享。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| NFR-7                     | **职责分离**          | `src/CSC8502_Assignment/` 负责通用的渲染逻辑、应用循环、场景管理，以及**具体的资源路径选择**。<br><br>`Engine/IAL/` 层负责定义“引擎提供的稳定系统 API”，其接口签名**直接使用** `nclgl` 数学类型。<br><br>`nclgl/`, `Engine/Custom/` 和 `Engine/Implementations/` 层负责“具体如何实现 API”。<br><br>不涉及任何预处理器宏；资源统一为 `.gltf`，参见 NFR-4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| NFR-8                     | **纯净的系统抽象**       | `src/CSC8502_Assignment/` 目录下的所有代码（NFR-1 中定义的例外除外）必须是 100% 纯净的（_指系统层面_）。它们**严禁** `#include` 任何来自 `nclgl`（数学库除外）、`Engine/Custom` 或 `Engine/Implementations` 的具体实现头文件。<br><br>它们**被授权** `#include` `nclgl` 数学库头文件。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| NFR-9                     | **统一的接口抽象模式**     | 架构**不再**采用 V11 的“混合抽象模式”。V13 架构采用单一、统一的抽象模型：<br><br>1. **(数据类型 - 直接耦合):** 对于数学库（`Vec3`, `Mat4`），引擎代码**直接 `#include "nclgl/Vector3.h"`** 并使用其**具体类型**。<br><br>2. **(服务/对象 - 依赖注入):** 对于 `IAL/` 提供的**纯虚接口**（`I_ResourceFactory`, `I_DebugUI`, `I_WindowSystem`, `I_Mesh` 等），引擎代码**严禁**直接实例化。<br><br>3. **(服务注入点):** 第 2 部分的依赖注入切换**必须**在 `src/CSC8502_Assignment/main.cpp` 中通过 `#ifdef NCL_USE_CUSTOM_IMPL` 宏实现。`main.cpp` 将根据宏定义，`include` 对应的具体实现头文件，并 `new` 或 `std::make_shared` 对应的具体工厂类（例如 `NCLGL_Impl::Factory` 或 `Custom::Factory`）**以及核心应用系统（例如 `NCLGL_Impl::WindowSystem` 或 `Custom::WindowSystem`）**。然后将这些**纯接口**注入到 `Renderer` 和 `Application` 中。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| NFR-10                    | **最小化服务接口**       | `IAL/` 中的**服务接口**（如 `I_ResourceFactory`, `I_DebugUI`, `I_WindowSystem`）的设计必须是最小化的，其每一个函数都必须由一个或多个功能需求（Section 2）来证明其存在的必要性。**严禁**“API 镜像”。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| NFR-11                    | **nclgl 风险评估**    | 轨道 B (`nclgl`) 的功能鸿沟和实现风险必须被正视。基于对所提供的 `nclgl` 库文件的分析，已确认：<br><br>1. **数学库:** `nclgl` 包含完整的数学库（`Vector2`, `Vector3`, `Vector4`, `Matrix2`, `Matrix3`, `Matrix4`, `Quaternion`）。V13 架构将完全依赖此库。<br><br>2. **动画支持:** `nclgl` **具备**骨骼动画支持（`MeshAnimation.h`, `Mesh.h` 中的 `WEIGHTVALUE_BUFFER`, `MeshAnimation.cpp`)。<br><br>3. **功能鸿沟:** `nclgl` **确认缺乏**一个即时模式 GUI 系统（`P-5` 的 UI 调参需求无法满足），**并且其 FBO 功能缺失（必须自研）**（`P-3` 后处理 和 `P-4` 阴影 需求无法满足）。<del>同时其模型加载器仅支持 `.msh` 格式。</del><br><br> <ins>**（已更新）** `nclgl` 库（`CSC8502 GLTF` 版本）**已包含** `nclgl/Extra/GLTFLoader.h`，提供了对 `.gltf` 模型、材质和骨骼动画的完整支持，原有的 `.msh` 加载风险已消除。</ins><br><br> 4. 已确认 `nclgl` 库的所有类（`Vector3`, `Window`, `OGLRenderer` 等）均位于全局命名空间。<br>- **应对:** 在我们自研的代码中（`Engine/IAL` 和 `CSC8502_Assignment`），应尽量使用 `Engine` 或其他命名空间来避免潜在的冲突。<br>- **编码规范:** 在实现层（`Implementations/`）涉及 `nclgl` 类时，需要使用全局作用域操作符 `::`（例如 `::Vector3`）来显式标明其来源，增强代码可读性<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| NFR-11.TEX-FBO            | 纹理与FBO系统级风险清单与约束  | 本节用于将纹理与帧缓冲在本项目中的“抽象位置”与“生命周期语义”明确写死，<br>以防止后期在 T2（废墟）场景或 Part B（阴影 / Bloom / SSAO）加入后出现渲染管线级别的隐式退化。<br><br>- 纹理生命周期与所有权  <br>    约束：`I_Texture` 在实现层必须仅持有 GPU 资源句柄的所有权语义，并与 `I_FrameBuffer` 的附件创建与释放解耦；任何“从 FBO 取回的纹理”与“由工厂直接加载的纹理”在生命周期上视为等价对象。  <br>    风险：跨模块共享 `GLuint` 时发生重复删除或悬挂句柄，导致渲染不确定性。  <br>    缓解：在工厂中统一创建与销毁语义；为所有 GPU 资源建立“单一释放点”的约定，并在验收中做静态/运行期审计（见 AC-NFR-11.TEX）。<br>    <br>- 纹理采样状态一致性  <br>    约束：采样状态（滤波、包裹、各向异性）必须在创建阶段一次性设置完毕；调试阶段严禁在渲染循环内反复切换。  <br>    风险：状态漂移导致画面抖动、锯齿或性能回退。  <br>    缓解：把采样状态记录进工厂级“资源描述”，并在加载日志中打印（可由 DebugUI 空实现忽略，轨道 C 可展示）。<br>    <br>- sRGB/线性空间与MRT一致性  <br>    约束：后期管线各阶段必须明示色域与 gamma 约定（颜色纹理、屏幕输出与中间缓冲一致）。  <br>    风险：过渡、Bloom 等后期出现发灰或过曝。  <br>    缓解：在 PostProcessing 初始化时记录并校验 FBO 的颜色附件内部格式与最终默认帧缓冲的一致性（见 Day 6 集成节点）。<br>    <br>- FBO 完整性（Completeness）与附件类型匹配  <br>    约束：后期与阴影的 FBO 必须在创建后立即验证完整性；深度附件与颜色附件尺寸必须一致；阴影使用的深度专用 FBO 禁止混入颜色附件。  <br>    风险：隐蔽的 GL 错误仅在某些驱动触发，提交风险高。  <br>    缓解：FBO 创建路径集成一次性完整性检查与错误统计，并将检查纳入验收（AC-NFR-11.3 已定义）。<br>    <br>- GL 状态污染与绑定顺序  <br>    约束：I_FrameBuffer::Bind/Unbind 必须为“成对语义”，禁止在渲染路径中“中途改绑而不回滚”；后期四边形绘制前必须明确绑定正确的读写目标。  <br>    风险：跨模块相互影响，出现黑屏或花屏。  <br>    缓解：将“绑定栈”作为调试开关在开发期启用，提交前关闭；在 Day 6 的集成测试中检查场景→FBO→Quad→屏幕的完整链路。<br>    <br>- 立方体贴图与坐标约定  <br>    约束：天空盒与反射若混用不同加载路径，必须统一右手/左手与贴图面朝向约定。  <br>    风险：天空盒接缝与反射翻转。  <br>    缓解：在 `LoadCubemap` 的资源描述中固定“面顺序与坐标系”清单，并在渲染时只在一个地方做一次性坐标修正。<br>    <br>    <br>- 调试 UI 缺失的观测性风险（轨道 B）  <br>    约束：轨道 B 的 DebugUI 为空实现，缺乏实时曝光调参与状态检验能力。  <br>    风险：难以及时发现与定位渲染参数错误。  <br>    缓解：把关键渲染状态落盘到日志（帧率、FBO 格式、纹理尺寸、阴影分辨率）；保持与 AC 检查项耦合（见下）。<br> |
| NFR-11.TEX-Type           | 纹理类型一致性约束         | 为避免未来在延迟渲染、Cubemap、阴影深度贴图、屏幕空间反射等场景中出现错误的绑定行为，本项目将纹理对象的“类型信息”视为渲染管线中的一等实体。`I_Texture` 实现层（如 `B_Texture`）**必须显式记录纹理类型**，类型在创建时确定并在生命周期内保持不变。<br><br>类型范围包括但不限于：`Tex2D`、`CubeMap`、`DepthTexture`、`ColorAttachment`。<br><br>**禁止**在未区分类型的情况下默认执行 `glBindTexture(GL_TEXTURE_2D, ...)`。所有 `Bind(slot)` 行为必须根据纹理类型选择正确的绑定目标。该条款保证后期链路加入反射探针、环境映射、阴影采样时无需修改应用层或渲染器层逻辑。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| NFR-11.FBO-Format         | FBO 颜色 / 深度附件格式标准 | 为避免后期链路加入 HDR、Bloom、ToneMapping、深度线性化和阴影时发生“颜色空间漂移 / 黑屏 / 过曝 / 伽马不一致”等不可调试问题，本项目对 FBO 创建的颜色 / 深度附件格式进行标准化约束。<br><br>**仅允许使用以下内部格式：**<br>• `Color8`（用于 LDR 通道、天空盒 UI 等）<br>• `Color16F`（用于 HDR 场景、Bloom 和 ToneMapping）<br>• `Depth24`（用于基础深度测试）<br>• `Depth32F`（用于高精度阴影 / 深度线性化）<br><br>FBO 的内部格式必须在创建时记录，并作为后期渲染阶段的格式一致性检查依据。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| NFR-11.Texture-AsyncReady | 纹理加载流程分层约束        | 本项目暂不实现异步纹理加载，但要求 `LoadTexture` 内部逻辑在设计上显式分为两个阶段：<br>1) **DecodeFromDisk**（文件解码 / CPU IO）<br>2) **UploadToGPU**（显存上传 / glTexImage）<br><br>此分层确保在未来需要加入 Streaming / 预加载 / 多线程 I/O 时，**无需修改 `IAL` 接口或应用层调用点**，从而保持架构连续性和可演化性。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| NFR-11.Transform-Order    | 局部变换矩阵乘法顺序风险      | 在 `SceneGraph::BuildLocalTransform()` 中，局部变换矩阵的构造顺序为  <br>`translation * rotation * scale`。此设计继承自 `nclgl` 教程体系，用于保持与 Rich Davison 原始渲染管线一致。<br><br>然而，该顺序意味着 **缩放在旋转之后被应用于原始局部坐标系**。因此当节点存在 90° 旋转时，缩放方向会“错位”，在特定情况下（例如 `Water` 类将 XY 平面旋转为 XZ 平面）会导致几何体被压扁成线。<br><br>**约束：**  <br>不得全局修改矩阵乘法顺序，否则将破坏所有父子节点的空间一致性。<br><br>**缓解策略：**<br><br>1. 保持 `SceneGraph` 不变，仅在 `Water::ConfigureNode()` 层面交换缩放轴（`scale=(halfWidth, halfDepth, 1.0f)`），使其与旋转后坐标系匹配。<br>    <br>2. 在架构文档中明确声明：任何局部旋转 90° 或 -90° 的平面节点，若视觉表现异常，应首先检查缩放轴定义，而非修改矩阵构造逻辑。<br>    <br>3. 在后续引入动画或骨骼节点时，保持此矩阵顺序不变，以避免姿态矩阵与物体空间错位。<br>    <br><br>**风险等级：** 中  <br>**影响范围：** `SceneGraph` 全局节点系统  <br>**状态：** 已识别并在 `Water` 节点中通过局部补偿策略解决。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| NFR-12                    | **资源格式 (轨道 C)**   | 轨道 C 的模型加载器（`C_Factory::LoadMesh`）必须支持 **gltf 2.0** 格式，以替代原定的 .obj 格式，从而更好地支持 PBR 材质和骨骼动画（P-4）。<br><br><ins>（注：轨道 B (nclgl) 现也已支持 `.gltf` 格式，这使得双轨切换无需更改资源路径，但轨道 C 的目标（自研实现）不变。）</ins>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| NFR-13                    | **技术债务与妥协 (新增)**  | 本项目为了在 `nclgl` 框架（轨道 B）上务实地实现 `P-4 (骨骼动画)` 需求，有意识地接受了技术债务。<br><br>  <br>  <br><br>1. `IAL/I_AnimatedMesh` 接口（见 Section 4.2）是一个**泄漏抽象** (Leaky Abstraction)，它暴露了 `GetBoneTransforms()` 方法。<br><br>  <br><br>2. 此设计直接映射到 `nclgl::MeshAnimation::GetJointData` 的实现（返回 `const Matrix4*`），并服务于 `skinning.vert` 着色器（见 Section 5, Day 18）的 `glUniform` 需求。<br><br>  <br><br>3. 我们接受此接口缺乏“演化性”（Evolvability）且不支持动画混合（Blending），以换取在轨道 B 上的**可实现性**和**满足课程评分标准**（`AC-P4.2`）。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| NFR-14                    | **轨道 C 优先级 (新增)** | 本项目（`CSC8502_Assignment`）的唯一交付目标是**轨道 B (nclgl) 实现**，其必须满足课程大纲 中的所有核心功能（Part A）和至少两个高级功能（Part B），并在 NESS 截止日期 前提交。<br><br>  <br>  <br><br>**轨道 C (自研)** 是一个交付后的、用于个人技术探索的演化目标。其开发进度**不得**以任何形式影响轨道 B 的交付质量和时间。Sprint 计划（Section 5）中提及的轨道 C 任务仅作为技术演化路径参考，并非交付承诺。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| NFR-15                    | **代码规范 **         | 每个 `.h` 与 `.cpp` 文件必须在文件开头包含唯一的 Doxygen 文档块（`/** ... */`），该文档块应完整说明该文件中包含的所有类、枚举、成员函数与成员变量的语义、职责、调用方式、约束与生命周期。<br><br>在此文档块之外，文件内部严禁出现任何形式的注释，包括但不限于 `//`、`/* ... */`、`///<`、`/*!<` 等注释形式。禁止在类体、枚举体、成员变量声明、函数声明、函数实现体内添加任何解释性注释。<br><br>所有解释性内容必须集中维护于文件头部的 Doxygen 文档块中，文件主体部分必须保持纯声明与纯实现代码，不得包含注释。本规范适用于 IAL 接口层、轨道 B/NCLGL_Impl、轨道 C/Custom_Impl 以及 CSC8502_Assignment 层的所有代码文件。<br>所有大括号应该使用K&R样式<br>本文档中的代码片段注释仅用于说明，**仓库源文件**必须遵守‘仅文件头 Doxygen、正文零注释’。<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |

## 4. 核心接口规范 (Internal Abstraction Layer)

**规范：** 本架构的核心是 `IAL` (Internal Abstraction Layer)。此层定义了 `Demo` 层（`src/CSC8502_Assignment/`）与具体系统实现（`nclgl` 或 `Custom`）之间的契约。

1. **通用数学库 (NFR-2):** `src/CSC8502_Assignment/`（`Demo` 层）和 `src/Engine/IAL/`（接口层）均**被授权**且**必须**直接 `#include "nclgl/Vector3.h"`、`"nclgl/Matrix4.h"` 等数学库头文件。这些类型（`Vector3`, `Matrix4` 等）在全局命名空间 (`::`) 中被直接使用，作为整个项目的“通用数学语言”。
    
2. **系统接口 (NFR-1:** `src/CSC8502_Assignment/` 目录（`main.cpp` 和 `Game/Scenes/` 除外）**严禁** `#include` 任何 `nclgl` 的**非数学**系统级头文件（例如 `nclgl/Mesh.h`, `nclgl/Shader.h`, `nclgl/Window.h`, `nclgl/OGLRenderer.h`）。
    
3. **依赖 (NFR-2):** `src/CSC8502_Assignment/` 目录（NFR-1 中定义的例外除外）的代码**必须且只能**依赖两类头文件：
    
    - `nclgl/` 目录下的数学库头文件。
        
    - `Engine/IAL/` 目录下的纯虚接口头文件。
        
4. **命名空间:** 所有 `IAL` 接口和枚举均定义在 `Engine::IAL` 命名空间下。
    

### 4.1 核心系统接口 (IAL/I_WindowSystem.h 等)

此层为应用程序的主循环、窗口和输入设备提供“纯虚接口”模式。这是 `Application` 类（位于 `CSC8502_Assignment`）运行的基础。

接口规范 (IAL)：

Demo 层的 Application 类必须通过构造函数注入 Engine::IAL::I_WindowSystem 接口。它通过此接口轮询消息、更新输入设备、并交换缓冲区。Application 对 nclgl::Window 或 nclgl::Keyboard 毫不知情。

**适配器规范 (Implementations)：**

- **轨道 B (`NCLGL_Impl`):** 必须提供 `B_WindowSystem`、`B_Keyboard` 和 `B_Mouse` 实现。
    
    - `B_WindowSystem` 是一个**高复杂度**的实现（NFR-11.4），它**必须**在内部实例化 `nclgl::Window` 并继承 `nclgl::OGLRenderer`（或持有其子类）以解决上下文创建（`wglCreateContext`）和 `SwapBuffers` 的问题。
        
    - `B_WindowSystem` **不能**直接创建 `B_Keyboard`，而**必须**在 `Init` 后调用 `nclgl::Window::GetKeyboard()`，获取 `nclgl` 在 `Window.cpp` 构造函数中自动实例化的 `static` `Keyboard` 指针，并将其**包装**在 `B_Keyboard` 适配器中返回（NFR-11.4）。`B_Mouse` 同理。
        
    - `B_Keyboard` **必须**实现 `IAL::KeyCode` 到 `nclgl::KeyboardKeys` 的映射。
        
- **轨道 C (`Custom_Impl`):** 必须提供 `C_WindowSystem` 等，使用自研的窗口/输入/上下文管理代码（例如 GLFW, SDL 或 Win32 API）。`C_Keyboard` 负责将 `GLFW_KEY_...` 映射到 `IAL::KeyCode`。
    

C++

```
/* 示例: src/Engine/IAL/I_InputDevice.h */
#pragma once

// 接口直接依赖 nclgl 通用数学库 (NFR-2)
#include "nclgl/Vector2.h"

namespace Engine::IAL {

    // (P-5 交互需求)
    // 必须定义独立于平台的按键枚举，以满足 NFR-1
    enum class KeyCode {
        UNKNOWN,
        W, A, S, D, SPACE,
        F, T, // 示例：F 切换自由相机, T 触发过渡
        LEFT_SHIFT, LEFT_CTRL,
        UP, DOWN, LEFT, RIGHT,
        ESCAPE
        // ... (根据需要添加 F1-F12, 0-9 等)
    };

    enum class MouseButton {
        LEFT, RIGHT, MIDDLE
        // ... (根据需要添加)
    };

    // 抽象了 nclgl::Keyboard
    class I_Keyboard {
    public:
        virtual ~I_Keyboard() {}
        
        // 抽象 nclgl::Keyboard::KeyDown
        // Demo 层将使用此函数检查按键，例如 P-5 要求的自由相机切换
        virtual bool KeyDown(KeyCode key) = 0; 
        virtual bool KeyHeld(KeyCode key) = 0;
        virtual bool KeyTriggered(KeyCode key) = 0;
    };

    // (P-5 交互需求)
    // 抽象了 nclgl::Mouse
    class I_Mouse {
    public:
        virtual ~I_Mouse() {}
        
        // 抽象 nclgl::Mouse::GetRelativePosition
        // 接口函数签名直接使用 nclgl 数学类型 (NFR-2)
        virtual Vector2 GetRelativePosition() = 0;
        
        // 抽象 nclgl::Mouse::ButtonDown
        virtual bool ButtonDown(MouseButton button) = 0; 
        // ... (ButtonHeld, ButtonTriggered, GetWheelMovement 等)
    };
} // namespace Engine::IAL
```

C++

```
/* 示例: src/Engine/IAL/I_WindowSystem.h */
#pragma once
#include <string>
#include <memory>
#include "IAL/I_InputDevice.h" // IAL 依赖 IAL (纯净)

namespace Engine::IAL {

    // 抽象 nclgl::GameTimer
    class I_GameTimer {
    public:
        virtual ~I_GameTimer() {}
        virtual float GetTimeDeltaSeconds() const = 0;
    };

    // 接口：核心系统 (P-0, P-5)
    // 抽象了 nclgl::Window 和 nclgl::OGLRenderer
    class I_WindowSystem {
    public:
        virtual ~I_WindowSystem() {}

        // 初始化窗口和 OpenGL 上下文
        virtual bool Init(const std::string& title, int sizeX, int sizeY, bool fullScreen) = 0;
        virtual void Shutdown() = 0;
        
        // 抽象 nclgl::Window::UpdateWindow
        // Demo 层的 Application 主循环将调用此函数
        virtual bool UpdateWindow() = 0; 
        
        // 抽象 nclgl::OGLRenderer::SwapBuffers
        virtual void SwapBuffers() = 0;

        // 抽象 nclgl::Window::GetHandle
        // 用于 I_DebugUI::Init
        virtual void* GetHandle() = 0;

        // 抽象 nclgl::Window::GetTimer
        virtual I_GameTimer* GetTimer() const = 0;

        // 抽象 nclgl::Window::GetKeyboard
        virtual I_Keyboard* GetKeyboard() const = 0;
        
        // 抽象 nclgl::Window::GetMouse
        virtual I_Mouse* GetMouse() const = 0;
    };

} // namespace Engine::IAL
```

### 4.2 渲染对象接口 (IAL/I_Mesh.h 等)

此层为渲染对象（Mesh, Shader, Texture）提供“纯虚接口”模式。

接口规范 (IAL)：

核心引擎代码 (Renderer 等) #include "IAL/I_Mesh.h" 并使用 Engine::IAL::I_Mesh* 或 std::shared_ptr<Engine::IAL::I_Mesh>。引擎严禁 new 这些对象。这些接口的具体实例（例如 NCLGL_Impl::B_Mesh 或 Custom_Impl::C_Mesh）必须由“资源工厂”(I_ResourceFactory) 创建。

**适配器规范 (Implementations)：**

- **轨道 B (`NCLGL_Impl`):**

	- `B_Mesh`, `B_Shader`, `B_Texture`, `B_AnimatedMesh` 必须是 `nclgl` 对应类的包装器（例如 `B_Mesh` 内部持有 `nclgl::Mesh*`，`B_Shader` 内部持有 `nclgl::Shader*`）。
    
	- `B_Texture` 将包装 `nclgl/Extra/OGLTexture.h` 中定义的 `OGLTexture` 类的共享指针 (`SharedTexture`)。
    
	- `B_AnimatedMesh` 必须同时包装 `nclgl::Mesh` 和 `nclgl::MeshAnimation`（NFR-13）。
    
	- `B_FrameBuffer` **必须是自研的**（NFR-11.3），因为它在 `nclgl` 库中没有对应实现（通过审查 `nclgl` 所有头文件确认）。
        
- **轨道 C (`Custom_Impl`):** 所有实现均必须是**自研**的。
    

C++

```
/* 示例: src/Engine/IAL/I_RenderingObjects.h (合并示例) */
#pragma once
#include <string>
#include <memory>
#include <vector>

// 接口直接依赖 nclgl 通用数学库 (NFR-2)
#include "nclgl/Matrix4.h"
#include "nclgl/Vector3.h"
#include "nclgl/Vector4.h"

namespace Engine::IAL {

    // 接口：着色器 (P-0, P-7)
    // 抽象了 nclgl::Shader
    class I_Shader {
    public:
        virtual ~I_Shader() {}
        
        // 对应 glUseProgram
        virtual void Bind() = 0;   
        virtual void Unbind() = 0; // 对应 glUseProgram(0)
        
        // (P-7 光照需求)
        // 接口函数签名直接使用 nclgl 数学类型 (NFR-2)
        // 抽象 nclgl::OGLRenderer::UpdateShaderMatrices 中的 glUniformMatrix4fv
        virtual void SetUniform(const std::string& name, const Matrix4& mat) = 0;
        virtual void SetUniform(const std::string& name, const Vector3& vec) = 0;
        virtual void SetUniform(const std::string& name, const Vector4& vec) = 0;
        virtual void SetUniform(const std::string& name, float f) = 0;
        virtual void SetUniform(const std::string& name, int i) = 0;
    };
    
    // 接口：纹理 (P-0, P-8)
    // 抽象 nclgl/Extra/OGLTexture.h
    class I_Texture {
    public:
        virtual ~I_Texture() {}
        virtual unsigned int GetID() = 0; // 引擎需要 ID 来绑定
        virtual void Bind(int slot = 0) = 0;
    };

    // 接口：网格 (P-0)
    // 抽象了 nclgl::Mesh
    class I_Mesh {
    public:
        virtual ~I_Mesh() {}
        
        // 抽象 nclgl::Mesh::Draw
        virtual void Draw() = 0;
    };
    
    // 接口：高度图 (P-0) (作为特殊网格)
    // nclgl 库没有 Heightmap 类，B_Heightmap 将包装一个 nclgl::Mesh
    class I_Heightmap : public I_Mesh {
    public:
        virtual ~I_Heightmap() {}
        // virtual Vector3 GetVertex(int x, int y) = 0; // 可选：用于物理或交互
    };
    
    // 接口：动画网格 (P-4)
    // 抽象了 nclgl::Mesh 和 nclgl::MeshAnimation
    class I_AnimatedMesh : public I_Mesh {
    public:
        virtual ~I_AnimatedMesh() {}
        virtual void UpdateAnimation(float dt) = 0;
        
        // 引擎需要设置骨骼变换
        // 接口函数签名直接使用 nclgl 数学类型 (NFR-2)
        // 抽象 nclgl::MeshAnimation::GetJointData
        // 这是一个有意的泄漏抽象 (NFR-13)
        virtual const std::vector<Matrix4>& GetBoneTransforms() const = 0;
    };
    
    // 接口：帧缓冲对象 (用于 P-3, P-4)
    // nclgl 库没有 FBO 类，B_FrameBuffer 必须自研 (NFR-11.3)
    class I_FrameBuffer {
    public:
        virtual ~I_FrameBuffer() {}
        virtual void Bind() = 0;
        virtual void Unbind() = 0;
        virtual std::shared_ptr<I_Texture> GetColorTexture() = 0;
        virtual std::shared_ptr<I_Texture> GetDepthTexture() = 0;
    };
    
} // namespace Engine::IAL
```

### 4.3 资源工厂接口 (IAL/I_ResourceFactory.h)

这是最重要的服务接口，负责创建所有渲染对象。它是 `Demo` 层与具体实现（轨道 B/C）之间的主要桥梁。

接口规范 (IAL)：

Demo 层的 Renderer 和 Scene 类必须通过构造函数注入 Engine::IAL::I_ResourceFactory 接口。此工厂负责加载和创建所有 I_Shader、I_Mesh 等对象。

**适配器规范 (Implementations)：**

- **轨道 B (`NCLGL_Impl`):** `B_Factory` 必须实现所有接口。

	- `CreateShader`: 包装 `new nclgl::Shader(...)`。
    
	- `LoadMesh` / `LoadAnimatedMesh`: **必须** `#include "nclgl/Extra/GLTFLoader.h"`。**必须**在内部调用 `GLTFLoader::Load(path, scene)`...
    
	    - `LoadTexture`: **必须** `#include "nclgl/Extra/OGLTexture.h"`。**必须**在内部调用 `OGLTexture::TextureFromFile(path)`，获取 `UniqueOGLTexture`，并将其包装在 `B_Texture` 适配器中返回。
        
	    - `LoadCubemap`: **必须** `#include "nclgl/Extra/OGLTexture.h"`。**必须**在内部调用 `OGLTexture::LoadCubemap(...)`，并将其返回的 `UniqueOGLTexture` 包装在 `B_Texture` 适配器中。
        
	    - `LoadHeightmap`: png加载器...
        
	    - `CreateQuad`: `nclgl::Mesh` **不**提供 `GenerateQuad`...
        
	    - `CreateShadowFBO` / `CreatePostProcessFBO`: 实例化**自研**的 `B_FrameBuffer`（NFR-11.3）。
        
- **轨道 C (`Custom_Impl`):** `C_Factory` 必须实例化所有**自研**的 `C_Shader`、`C_Mesh`、`C_MeshLoader`（支持 `.gltf` [NFR-12]）、`C_FrameBuffer` 等。
    

C++

```
/* 示例: src/Engine/IAL/I_ResourceFactory.h */
#pragma once
#include <string>
#include <memory>

// 接口直接依赖 nclgl 通用数学库 (NFR-2)
#include "nclgl/Vector3.h"

// IAL 依赖 IAL (纯净)
#include "IAL/I_Shader.h"
#include "IAL/I_Mesh.h"
#include "IAL/I_Texture.h"
#include "IAL/I_Heightmap.h"
#include "IAL/I_AnimatedMesh.h"
#include "IAL/I_FrameBuffer.h"

namespace Engine::IAL {

    // 接口：资源工厂 (核心)
    class I_ResourceFactory {
    public:
        virtual ~I_ResourceFactory() {}
        
        // P-0, P-7 (NFR-6: 共享着色器)
        virtual std::shared_ptr<I_Shader> CreateShader(
            const std::string& vPath, 
            const std::string& fPath, 
            const std::string& gPath = "") = 0;
        
        // P-0 (静态模型)
        // 路径由 Demo 层的 Game/Scenes/ 根据 NFR-4 决定
        virtual std::shared_ptr<I_Mesh> LoadMesh(const std::string& path) = 0;
        
        // P-0 (纹理)
        virtual std::shared_ptr<I_Texture> LoadTexture(
            const std::string& path, bool repeat = false) = 0;
        
        // P-8 (环境贴图)
        virtual std::shared_ptr<I_Texture> LoadCubemap(
            const std::string& negx, const std::string& posx, 
            const std::string& negy, const std::string& posy, 
            const std::string& negz, const std::string& posz) = 0;
            
        // P-0 (地形)
        // 接口函数签名直接使用 nclgl 数学类型 (NFR-2)
        virtual std::shared_ptr<I_Heightmap> LoadHeightmap(
            const std::string& path, const Vector3& scale) = 0;
        
        // P-0 (水体), P-3 (后处理)
        virtual std::shared_ptr<I_Mesh> CreateQuad() = 0;

        // P-4 (阴影)
        virtual std::shared_ptr<I_FrameBuffer> CreateShadowFBO(int width, int height) = 0;
        
        // P-3 (后处理)
        virtual std::shared_ptr<I_FrameBuffer> CreatePostProcessFBO(int width, int height) = 0;
        
        // P-4 (动画)
        // 路径由 Demo 层的 Game/Scenes/ 根据 NFR-4 决定
        // 轨道 B (nclgl) 和 轨道 C (Custom) 均加载 .gltf 格式 (NFR-4, NFR-11.3)
        virtual std::shared_ptr<I_AnimatedMesh> LoadAnimatedMesh(
            const std::string& path, 
            const std::string& animPathOrName = "") = 0; // animPathOrName 可选
    };

} // namespace Engine::IAL
```

### 4.4 调试UI抽象层 (IAL/I_DebugUI.h)

一个纯净的即时模式 GUI 接口 (P-5)。

接口规范 (IAL)：

Demo 层的 Renderer 或 Application 类必须通过构造函数注入 Engine::IAL::I_DebugUI 接口。

**适配器规范 (Implementations)：**

- **轨道 B (`NCLGL_Impl`):** (NFR-11.3) **必须**提供 `B_DebugUI_Null` 空实现，因为 `nclgl` 库缺乏 GUI 功能。`Init`, `NewFrame`, `SliderFloat` 等所有函数均为空函数体。
    
- **轨道 C (`Custom_Impl`):** **必须**提供 `C_DebugUI`，一个功能完整的**自研** IMGUI 系统（例如，基于 `stb_truetype` 和自研 2D 渲染器，或集成 ImGui）。
    

C++

```
/* 示例: src/Engine/IAL/I_DebugUI.h */
#pragma once
#include <string>

// 接口直接依赖 nclgl 通用数学库 (NFR-2)
#include "nclgl/Vector3.h"

namespace Engine::IAL {

    class I_DebugUI {
    public:
        virtual ~I_DebugUI() {}
        
        // void* 避免包含 GLFW/Window.h 或 nclgl::Window.h
        // 此 handle 将由 I_WindowSystem::GetHandle() 提供
        virtual void Init(void* windowHandle) = 0; 
        virtual void NewFrame() = 0;
        virtual void Render() = 0;
        virtual void Shutdown() = 0;

        // P-5 交互需求
        virtual bool BeginWindow(const std::string& title) = 0;
        virtual void EndWindow() = 0;
        virtual bool SliderFloat(const std::string& label, float* v, float v_min, float v_max) = 0;
        
        // 接口函数签名直接使用 nclgl 数学类型 (NFR-2)
        virtual bool SliderFloat3(const std::string& label, Vector3* v, float v_min, float v_max) = 0;
        
        virtual bool Checkbox(const std::string& label, bool* v) = 0;
        virtual bool Button(const std::string& label) = 0;
        virtual void Text(const std::string& text) = 0;
        
        // 接口函数签名直接使用 nclgl 数学类型 (NFR-2)
        virtual bool ColorEdit3(const std::string& label, Vector3* v) = 0;
    };

} // namespace Engine::IAL
```

### 4.5 依赖注入入口点 (main.cpp)

根据（NFR-9）规范，服务/对象接口（`IAL/`）的实现切换**必须**在 `main.cpp` 中通过预处理器宏完成。

规范：

main.cpp 是唯一被授权 #include 具体实现（Implementations/）头文件的核心引擎文件（NFR-1）。它将根据 #ifdef NCL_USE_CUSTOM_IMPL 宏来实例化具体的核心系统（I_WindowSystem）和服务（I_ResourceFactory, I_DebugUI），然后将这些纯接口注入到 Application 中。

#### 4.5.1 示例：main.cpp 中的注入逻辑

C++

```
/* 示例: src/CSC8502_Assignment/main.cpp */

#include <memory>
#include "Core/Application.h" // 纯净的，只依赖 IAL 和 nclgl-math

// IAL 接口 (纯净)
#include "IAL/I_WindowSystem.h"
#include "IAL/I_ResourceFactory.h"
#include "IAL/I_DebugUI.h"

// --- 依赖注入切换 (NFR-4, NFR-9) ---
// 
// #define NCL_USE_CUSTOM_IMPL // 取消注释此行以切换到轨道 C (自研) [NFR-14]

#ifdef NCL_USE_CUSTOM_IMPL
    // --- 轨道 C: 自研实现 ---
    // main.cpp 被授权包含具体实现 (NFR-1)
    #include "Implementations/Custom_Impl/C_WindowSystem.h"
    #include "Implementations/Custom_Impl/C_Factory.h"
    #include "Implementations/Custom_Impl/C_DebugUI.h"
#else
    // --- 轨道 B: nclgl 默认实现 ---
    // main.cpp 被授权包含具体实现 (NFR-1)
    #include "Implementations/NCLGL_Impl/B_WindowSystem.h"
    #include "Implementations/NCLGL_Impl/B_Factory.h"
    #include "Implementations/NCLGL_Impl/B_DebugUI_Null.h"
#endif

// -----------------------------------------------------------------

int main() {
    // 1. 实例化核心系统 (Window, Input, Timer)
    //    代码根据 NCL_USE_CUSTOM_IMPL 宏在编译时选择
    
    std::shared_ptr<Engine::IAL::I_WindowSystem> windowSystem;

#ifdef NCL_USE_CUSTOM_IMPL
    windowSystem = std::make_shared<Custom_Impl::C_WindowSystem>();
#else
    windowSystem = std::make_shared<NCLGL_Impl::B_WindowSystem>();
#endif

    // 2. 初始化核心系统
    if (!windowSystem->Init("CSC8502 Demo", 1280, 720, false)) {
        return -1;
    }

    // 3. 实例化依赖的服务 (Factory, UI)
    std::shared_ptr<Engine::IAL::I_ResourceFactory> resourceFactory;
    std::shared_ptr<Engine::IAL::I_DebugUI> debugUI;

#ifdef NCL_USE_CUSTOM_IMPL
    // 轨道 C
    resourceFactory = std::make_shared<Custom_Impl::C_Factory>();
    debugUI         = std::make_shared<Custom_Impl::C_DebugUI>();
#else
    // 轨道 B
    resourceFactory = std::make_shared<NCLGL_Impl::B_Factory>();
    debugUI         = std::make_shared<NCLGL_Impl::B_DebugUI_Null>(); // (NFR-11.3)
#endif
    
    // 4. 初始化依赖服务 (UI 需要 Window Handle)
    debugUI->Init(windowSystem->GetHandle());

    // 5. 注入 IAL 接口
    //    Application 对轨道 B 或 C 毫不知情，
    //    它只接收 Engine::IAL::... 纯接口。
    Application app(windowSystem, resourceFactory, debugUI);
    app.Run();
    
    // 6. 清理
    debugUI->Shutdown();
    windowSystem->Shutdown();
    
    return 0;
}
```
## 5. 实施阶段 (Sprints) - 每日作战计划

本阶段将严格遵循 `NFR-14`（轨道 B 优先交付）原则。所有“轨道 C” (自研) 相关的任务均被视为**交付后**的个人演化目标，并已从以下交付计划中移除，以确保所有资源都集中在满足课程大纲 要求的“轨道 B” (`nclgl`) 实现上。时间仅为顺序参考，重点在于完成任务和管理风险。

#### 里程碑阻断条件

为了降低提交前的不可逆渲染风险，每个 Sprint 结束前必须满足以下阻断条件，未通过不得进入下一 Sprint：

1. FBO 完整性通过且日志留痕；2) 资源（纹理/立方体贴图/高度图）加载路径统一且具备采样状态记录；3) 无跨模块 GL 状态泄漏（至少一次“Bind→Draw→Unbind”链路自检通过）；4) 轨道 B 下的 DebugUI 空实现不影响上述三项的验证流程（以日志代替 UI 观测）。

### Sprint 1: 核心架构与 `nclgl` 风险攻坚 (7 天)

- **目标:** 搭建“接口驱动架构”，**验证核心系统抽象**（`I_WindowSystem`, `I_InputDevice`）和 `nclgl` 数学库的直接耦合 (NFR-2)。构建**核心渲染管线**，包括 `SceneGraph` (P-6) 和 `PostProcessing` 框架 (P-3)。**解决 `nclgl` 的核心实现风险**（FBO 缺失 `[NFR-11.3]`、窗口/渲染器循环依赖 `[NFR-11.4]`、输入法自动实例化 `[NFR-11.4]`）。
    
- **交付物:** 一个可以渲染基础立方体（`cube.gltf`）的、完全基于 `IAL` 接口的 `Demo` 框架。
    
- **每日任务:**
    
    - **Day 1: (接口) IAL 接口与项目结构**
        
        - **任务:** 创建 V13 目录结构：`src/Engine/IAL/`, `src/Engine/Implementations/NCLGL_Impl/`。
            
        - **任务:** 根据第 4 章的规范，在 `src/Engine/IAL/` 中定义所有纯虚接口（`I_WindowSystem`, `I_InputDevice`, `I_GameTimer`, `I_Shader`, `I_Mesh`, `I_Texture`, `I_AnimatedMesh`, `I_FrameBuffer`, `I_ResourceFactory`, `I_DebugUI`）。
            
        - **任务 (关键):** `IAL/I_InputDevice.h` **必须**定义 `Engine::IAL::KeyCode` 和 `Engine::IAL::MouseButton` 平台无关枚举，以满足 4.1 节规范和 NFR-1。
            
        - **任务:** 所有 `IAL` 头文件（例如 `I_Shader.h`）**必须** `#include "nclgl/Vector3.h"` 和 `"nclgl/Matrix4.h"` 等，以便在其函数签名中直接使用 `nclgl` 的具体数学类型 (NFR-2)。
            
        - **验收:** V13 目录结构建立。所有 `IAL` 纯虚接口头文件定义完毕并可成功编译。
            
    - **Day 2: (注入) 依赖注入与 `main.cpp` (NFR-9)**
        
        - **任务:** 编写 `src/CSC8502_Assignment/main.cpp`。严格按照 4.5.1 节的规范，实现依赖注入逻辑。`main.cpp` 必须包含（但默认注释掉）`#ifdef NCL_USE_CUSTOM_IMPL` 宏块。
            
        - **任务:** 创建所有“轨道 B” (`NCLGL_Impl`) 的**实现空壳 (Stubs)**：`B_Factory.h/.cpp`, `B_WindowSystem.h/.cpp`, `B_InputDevice.h/.cpp`, `B_DebugUI_Null.h/.cpp` 等。
            
        - **任务:** 创建 `src/CSC8502_Assignment/Core/Application.h`，使其构造函数**必须**接受 `Engine::IAL::I_WindowSystem`, `Engine::IAL::I_ResourceFactory` 和 `Engine::IAL::I_DebugUI` 接口。
            
        - **验收:** `main.cpp` 编译通过。项目（轨道 B）可成功编译和链接，运行后（由于是空壳）立刻退出。
            
	- **Day 3: (高风险) `I_WindowSystem` 实现 (轨道 B) (NFR-11.4)**

	    - **目标与策略:**
	        * **目标:** 完整实现 `B_WindowSystem` 以驱动应用主循环。
	        * **核心策略:** 采用**组合模式 (Composition)**，让 `B_WindowSystem` 持有 `::Window*` 和 `::OGLRenderer*` 的实例，以解决 `OGLRenderer(Window&)` 构造函数的依赖强制性。
	
	    - **任务 1 (内部桩类):** 在 `B_WindowSystem.cpp` 内部定义一个私有的、继承自全局 `::OGLRenderer` 的辅助类（例如 `InternalRenderer`）。该类必须提供一个以 `::Window&` 为参数的构造函数，并实现空的纯虚函数 `RenderScene()`。
	        * **原因:** 规避 `B_WindowSystem` 难以在构造阶段满足 `OGLRenderer` 依赖的限制，同时满足 `OGLRenderer` 必须被继承才能实例化的约束。
	
	    - **任务 2 (成员与初始化):** `B_WindowSystem` 必须持有 `::Window* m_Window` 和 `::OGLRenderer* m_Renderer`。
	        * **依赖关系:** `B_WindowSystem::Init` 函数的逻辑顺序必须是：1. `new ::Window(...)` -> 2. `new InternalRenderer(*m_Window)` -> 3. `m_Window->SetRenderer(m_Renderer)`。
	
	    - **任务 3 (输入风险):** `B_WindowSystem::GetKeyboard()` 和 `B_WindowSystem::GetMouse()` **必须**从 `m_Window` 实例中获取由 `nclgl` 自动实例化到全局命名空间的 `static` `Keyboard` 和 `Mouse` 指针，并将其**包装**在 `B_Keyboard` 和 `B_Mouse` 适配器中返回 (NFR-11.4)。
	
	    - **任务 4 (输入映射):** 实现 `B_Keyboard` 和 `B_Mouse` 适配器。
	        * `B_Keyboard` **必须**实现 `IAL::KeyCode` 到全局 `::KeyboardKeys` 的完整映射。
	        * `B_Mouse` **必须**实现 `IAL::MouseButton` 到全局 `::MouseButtons` 的完整映射。
	
	    - **任务 5 (计时器):** 实现 `B_GameTimer` 适配器，其内部**必须**包装 `new ::GameTimer()` 的实例，并实现 `I_GameTimer` 接口（例如 `GetTimeDeltaSeconds()`）。
	
	    - **任务 6 (功能委托):** `B_WindowSystem::UpdateWindow()` 必须委托给 `m_Window->UpdateWindow()`；`B_WindowSystem::SwapBuffers()` 必须委托给 `m_Renderer->SwapBuffers()`。

	    - **验收:** 轨道 B（`main.cpp` 中注释 `#define NCL_USE_CUSTOM_IMPL`）程序成功运行。`Application` 主循环调用 `window->UpdateWindow()` 和 `window->SwapBuffers()`，显示一个空白的 nclgl 窗口并可正常关闭。风险 `NFR-11.4` 被验证为已通过组合模式和适配器处理。
		
    - **Day 4: 核心渲染器与场景图 (P-6)**
        
        - **任务:** 实现 `src/CSC8502_Assignment/Core/SceneGraph.h` (P-6)。`SceneNode` **必须** `#include "nclgl/Matrix4.h"` 和 `"nclgl/Vector3.h"` (NFR-2) 来存储变换。
            
        - **任务:** `SceneNode` **必须**依赖 `Engine::IAL::I_Mesh` 接口来进行渲染。
            
        - **任务:** 实现 `src/CSC8502_Assignment/Core/SceneManager.h`。
            
        - **任务:** 实现 `src/CSC8502_Assignment/Rendering/Renderer.h`。`Renderer` 的构造函数**必须**接受 `IAL` 接口（`I_ResourceFactory` 等）。
            
        - **任务:** `Application.cpp` 的主循环**必须**按顺序调用 `window->UpdateWindow()`, `sceneManager->Update(dt)`, `renderer->Render()`, `window->SwapBuffers()`。
            
        - **验收:** 核心架构（`SceneGraph`, `SceneManager`, `Renderer`）搭建完毕，主循环逻辑正确。
            
    - **Day 5: (高风险) FBO (P-3/P-4) 框架 (NFR-11.3)**
        
        - **任务:** 确保 `IAL/I_ResourceFactory.h` 包含 `CreatePostProcessFBO` 和 `CreateShadowFBO` 接口。
            
        - **任务 (NFR-11.3):** 在 `Implementations/NCLGL_Impl/` 中实现 `B_FrameBuffer.h/.cpp`。此实现**必须是自研的**，使用原生 OpenGL API (`glGenFramebuffers`, `glFramebufferTexture2D`, `glDrawBuffers` 等)，因为 `nclgl` 库缺失此功能。
            
        - **任务:** 实现 `B_Factory::CreatePostProcessFBO` 和 `CreateShadowFBO`，使其 `new B_FrameBuffer(...)` 并返回 `std::shared_ptr<I_FrameBuffer>`。
            
        - **任务:** `B_FrameBuffer` **必须**依赖 `IAL/I_Texture` 接口，并能正确生成包装了 `OGLTexture` 的 `B_Texture` 实例作为颜色和深度附件。
            
        - **验收:** FBO 框架和工厂方法实现。风险 `NFR-11.3` 被验证为已处理。
			
        - Day 5 补充检查：创建的阴影与后期 FBO 分别通过完整性校验；2) 颜色与深度附件分辨率一致；3) 渲染完成后，恢复到默认帧缓冲（显式 Unbind）。结果记录在构建日志中（成功/失败与附件规格）。
            
    - **Day 6: PostProcessing (P-3) 与管线集成**
        
        - **任务:** 实现 `src/CSC8502_Assignment/Rendering/PostProcessing.h`。此模块**必须**依赖 `I_ResourceFactory` 来调用 `CreatePostProcessFBO()` 和 `CreateQuad()`。
            
        - **任务 (轨道 B):** `B_Factory` **必须**实现 `CreateQuad`。`nclgl::Mesh` 未提供 `GenerateQuad`，因此**必须**采用（NFR-11.3）**继承策略**：在 `B_Factory.cpp` 中定义一个继承自 `nclgl::Mesh` 的辅助类，在构造函数中填充四边形数据并调用 `protected` 的 `BufferData()` 方法。
            
        - **任务:** `Renderer` **必须**被修改：首先将 `SceneGraph` 渲染到 `PostProcessing` 模块的 FBO，然后 `PostProcessing` 模块（暂时作为直通）渲染到屏幕。
            
        - **验收:** FBO 框架和后处理管线在轨道 B 下可运行。屏幕（暂时）全黑或显示清除色，但管线（Scene -> FBO -> Quad -> Screen）已打通。
			
        - Day 6 补充检查：场景→后期FBO→屏幕的绘制目标切换在日志中出现连续三段记录；2) 后期直通输出与默认清屏色一致性验证（用于定位伽马错误）。
    - **Day 7: 架构验证 (Hello Cube)**
        
        - **任务 (轨道 B):**
            
            - `B_Factory`: 实现 `CreateShader` (包装 `new nclgl::Shader`)。
                
            - `B_Factory`: 实现 `LoadMesh`。**必须**使用 `GLTFLoader`（已在 Day 5 B_Factory 中）加载 `cube.gltf` 并包装 `B_Mesh`。
                
        - **任务:** `SceneManager` 创建一个默认场景，向 `SceneGraph` (P-6) 添加一个 `SceneNode`，该节点持有 `m_Factory->LoadMesh("third_party/nclgl/Meshes/cube.gltf")` 返回的 `I_Mesh`。
            
        - **任务:** `Renderer` **必须**使用一个基础着色器（通过 `m_Factory->CreateShader` 创建）来渲染 `SceneNode`。
            
        - **验收:** (关键) 在轨道 B 下，成功渲染一个立方体。立方体**必须**是通过 `SceneGraph` 遍历、渲染到 `PostProcessing` FBO（`B_FrameBuffer`）、最后通过全屏四边形（`CreateQuad`）显示到 `B_WindowSystem` 窗口的。架构验证通过。
            

#### Sprint 1 完成后项目结构 (核心框架)

```
CSC8502_Framework/
|-- Assets/
|   `-- Shaders/Shared/
|       |-- basic.vert
|       `-- basic.frag
|-- third_party/
|   `-- nclgl/
|       |-- Meshes/
|       |   `-- cube.gltf
|       |-- (nclgl 库文件) ...
`-- src/
    |-- Engine/
    |   |-- IAL/
    |   |   |-- I_WindowSystem.h
    |   |   |-- I_InputDevice.h
    |   |   |-- I_GameTimer.h
    |   |   |-- I_ResourceFactory.h
    |   |   |-- I_Shader.h
    |   |   |-- I_Mesh.h
    |   |   |-- I_Texture.h
    |   |   |-- I_AnimatedMesh.h
    |   |   |-- I_FrameBuffer.h
    |   |   `-- I_DebugUI.h
    |   `-- Implementations/NCLGL_Impl/
    |       |-- B_WindowSystem.h/.cpp     (已实现, 继承 OGLRenderer)
    |       |-- B_InputDevice.h/.cpp      (已实现, 包装 static 实例)
    |       |-- B_GameTimer.h/.cpp        (已实现, 包装 GameTimer)
    |       |-- B_Factory.h/.cpp        (实现 CreateShader, LoadMesh, CreateQuad, Create...FBO)
    |       |-- B_Shader.h/.cpp         (已实现, 包装 Shader)
    |       |-- B_Mesh.h/.cpp           (已实现, 包装 Mesh)
    |       |-- B_Texture.h/.cpp        (已实现, 包装 OGLTexture)
    |       |-- B_FrameBuffer.h/.cpp    (已实现, 自研 OpenGL)
    |       |-- B_AnimatedMesh.h/.cpp   (空壳)
    |       |-- B_DebugUI_Null.h/.cpp   (空壳)
    |       `-- B_Heightmap.h/.cpp      (空壳)
    `-- CSC8502_Assignment/
        |-- Core/
        |   |-- Application.h/.cpp      (已实现, 包含主循环)
        |   |-- SceneManager.h/.cpp     (已实现)
        |   `-- SceneGraph.h/.cpp       (已实现)
        |-- Rendering/
        |   |-- PostProcessing.h/.cpp   (已实现, FBO->Quad 管线)
        |   `-- Renderer.h/.cpp         (已实现, 遍历 SceneGraph)
        `-- main.cpp                    (已实现, 注入轨道 B)
```

---

### Sprint 2: 核心场景 T1 (和平) (6 天)

- **目标:** 实现 Part A 核心功能 (P-0 地形, P-8 天空盒, P-7 基础光照, 水体)。将 Sprint 1 的空管线填充为 T1 场景。
    
- **交付物:** 一个完整的 T1 场景（和平时期），包含光照、地形、天空盒和水体，并可通过 `IAL` 接口实现自由相机（P-5）。
    
- **每日任务:**
    
    - **Day 8: (核心) Camera (P-5) 与 IAL::Input (P-5)**
        
        - **任务:** 实现 `src/CSC8502_Assignment/Core/Camera.h`。相机逻辑**必须** `#include "nclgl/Vector3.h"` 和 `"nclgl/Matrix4.h"` (NFR-2)。
            
        - **任务:** `Camera::BuildViewMatrix()` **必须**直接调用 `Matrix4::BuildViewMatrix(...)`。
            
        - **任务:** `Application.cpp` **必须**从 `I_WindowSystem` 获取 `I_Keyboard` 和 `I_Mouse` 接口。
            
        - **任务:** 在 `Camera::Update` 中实现“自由相机” (P-5) 逻辑，**必须**使用 `IAL` 接口（例如 `keyboard->KeyDown(Engine::IAL::KeyCode::W)`）。
            
        - **验收:** 在 Sprint 1 的 Cube 场景中，相机可以使用 `IAL` 抽象的 `WASD` 键自由飞行。
            
    - **Day 9: (接口) IAL (Texture) & IAL (Heightmap) (P-0)**
        
        - **任务:** 在 `IAL/I_ResourceFactory.h` 中添加 `LoadTexture` 和 `LoadHeightmap` 接口。
            
        - **任务 (轨道 B):**
            
            - `B_Factory`: 实现 `LoadTexture`。**必须**调用 `OGLTexture::TextureFromFile(path)` 来创建 `OGLTexture` 实例，并将其包装在 `B_Texture` 适配器中。
                
            - `B_Factory`: 实现 `LoadHeightmap`。**必须**在 `B_Factory.cpp` 中定义一个**私有辅助类**（例如 `B_HeightmapMesh_NCLGL`）使其**公有继承** `nclgl::Mesh`。**必须**在该辅助类的构造函数中自研 `.png` 加载器、填充 `protected` 的 `vertices`, `indices`, `textureCoords` 成员，并调用 `protected` 的 `BufferData()` 方法。`LoadHeightmap` 接口将 `new` 这个辅助类，并将其包装在 `B_Heightmap` 适配器中 (NFR-11.3)。
                
        - **验收:** `IAL` 接口定义完毕。轨道 B 的工厂均可加载纹理和高度图。
            
    - **Day 10: (渲染) 地形渲染 (P-0) 与场景 T1 (P-2)**
        
        - **任务:** 创建 `src/CSC8502_Assignment/Game/Scenes/Scene_T1_Peace.h`。
            
        - **任务:** `SceneManager` 修改为加载 `Scene_T1_Peace`。
            
        - **任务:** `Scene_T1_Peace::Init()` **必须**调用 `m_Factory->LoadHeightmap("Assets/Heightmaps/terrain.png", ...)` 和 `m_Factory->LoadTexture("Assets/Textures/terrain_grass.png")`。
            
        - **任务:** `Scene_T1_Peace` **必须**将返回的 `I_Heightmap` 添加到 `SceneGraph` (P-6)。
            
        - **任务:** 创建 `Assets/Shaders/Shared/terrain.vert/frag` (NFR-6)，用于地形渲染。
            
        - **验收:** 轨道 B 成功加载并渲染带纹理的地形 (P-0)。
            
    - **Day 11: (渲染) IAL (Skybox) (P-8) 与光照 (P-7)**
        
        - **任务:** 在 `IAL/I_ResourceFactory.h` 中添加 `LoadCubemap` 接口 (P-8)。
            
        - **任务 (轨道 B):** 实现 `B_Factory::LoadCubemap`，**必须**调用 `nclgl` 库中 `OGLTexture::LoadCubemap(...)` 功能，并将其返回的实例包装在 `B_Texture` 适配器中。
            
        - **任务:** `Renderer.cpp` 添加 Skybox 渲染逻辑（在 `PostProcessing` FBO 渲染，但在水体反射之前）。
            
        - **任务:** 实现 `src/CSC8502_Assignment/Core/Light.h` 结构体 (数据**必须**使用 `nclgl::Vector3`)。
            
        - **任务:** `Renderer` **必须**将 `Light` 信息（位置、颜色、环境光）传递给 `terrain.frag` (NFR-6) 和其他着色器。
            
        - **任务:** `terrain.frag` **必须**实现 Blinn-Phong 光照 (P-7)，包含环境、漫反射和高光计算。
            
        - **验收:** T1 场景 (P-2) 渲染完成，包含地形 (P-0)、天空盒 (P-8) 和 Blinn-Phong 光照 (P-7)。
            
    - **Day 12: (渲染) 水体渲染 (P-0)**
        
        - **任务:** 实现 `src/CSC8502_Assignment/Rendering/Water.h`。水体节点**必须**添加到 `SceneGraph` (P-6) 中。
            
        - **任务:** `Water` 节点**必须**使用 `m_Factory->CreateQuad()`（已在 Day 6 实现）。
            
        - **任务:** `Renderer` **必须**被重构，以支持水体所需的递归渲染：
            
            1. `RenderScene` (用于水体反射，剪裁平面反转)。
                
            2. `RenderScene` (用于水体折射)。
                
            3. `RenderScene` (主渲染)。
                
            
            - （此步骤将重用 Day 5 创建的 `I_FrameBuffer` 接口）。
                
        - **验收:** T1 场景包含水体 (P-0)，具有（至少是静态的）反射和折射效果。
            
    - **Day 13: (交互) IAL (DebugUI) (P-5)**
        
        - **任务 (轨道 B):** 完整实现 `Implementations/NCLGL_Impl/B_DebugUI_Null.h/.cpp` (NFR-11.3)。所有 `IAL` 接口函数（`BeginWindow`, `SliderFloat` 等）**必须**为空函数体。
            
        - **任务:** `Application.cpp` **必须**在主循环中调用 `debugUI->NewFrame()` 和 `debugUI->Render()`。
            
        - **任务:** `Renderer.cpp` 或 `Scene_T1_Peace.cpp` **必须**使用 `I_DebugUI` 接口添加滑块（即使它们在轨道 B 中不执行任何操作），以控制光照位置和颜色 (P-5)。
            
        - **验收:** 轨道 B 正常运行（无 UI）。`Demo` 层的 UI 调用被空实现正确处理，不导致崩溃。
	        
    - Sprint 2 追加检查点（资源一致性）
    - 
		- 纹理加载一致性
		    
		    1. 单一工厂路径产出的纹理对象都具备同一套采样状态；2) sRGB/线性开关在后期链路文档中有记录。
		        
		- 立方体贴图规范
		    
		    1. 天空盒六面命名与顺序固定；2) 首帧输出检查接缝与翻转，若异常则禁止继续迭代渲染特效

#### Sprint 2 完成后项目结构 (T1 场景)

```
CSC8502_Framework/
|-- Assets/
|   |-- Heightmaps/
|   |   `-- terrain.png
|   |-- Shaders/Shared/
|   |   |-- (basic...)
|   |   |-- skybox.vert/frag
|   |   |-- terrain.vert/frag     (含 Blinn-Phong P-7)
|   |   `-- water.vert/frag
|   `-- Textures/
|       |-- terrain_grass.png
|       `-- skybox_peace/         (6 张 .png)
|-- third_party/
|   `-- nclgl/
|       |-- (nclgl 库文件) ...
`-- src/
    |-- Engine/
    |   |-- IAL/ (无变化)
    |   `-- Implementations/NCLGL_Impl/
    |       |-- B_WindowSystem.h/.cpp     (已实现)
    |       |-- B_InputDevice.h/.cpp      (已实现)
    |       |-- B_GameTimer.h/.cpp        (已实现)
    |       |-- B_Factory.h/.cpp        (已实现 LoadTexture, LoadHeightmap, LoadCubemap)
    |       |-- B_Shader.h/.cpp         (已实现)
    |       |-- B_Mesh.h/.cpp           (已实现)
    |       |-- B_Texture.h/.cpp        (已实现)
    |       |-- B_FrameBuffer.h/.cpp    (已实现)
    |       |-- B_Heightmap.h/.cpp      (已实现, png 加载器 + 包装 Mesh)
    |       |-- B_DebugUI_Null.h/.cpp   (已实现, 空函数体 NFR-11.3)
    |       `-- B_AnimatedMesh.h/.cpp   (空壳)
    `-- CSC8502_Assignment/
        |-- Core/
        |   |-- Application.h/.cpp      (已集成 Camera, Input)
        |   |-- Camera.h/.cpp         (已实现, 含自由相机 P-5)
        |   |-- Light.h             (已实现)
        |   |-- SceneManager.h/.cpp     (加载 T1 Scene)
        |   `-- SceneGraph.h/.cpp       (已实现)
        |-- Game/
        |   `-- Scenes/
        |       `-- Scene_T1_Peace.h/.cpp (已实现, 加载地形/天空盒 P-0, P-8)
        |-- Rendering/
        |   |-- PostProcessing.h/.cpp   (已实现)
        |   |-- Renderer.h/.cpp         (已实现, 含光照 P-7, Skybox P-8, 水体 P-0 渲染)
        |   `-- Water.h/.cpp            (已实现)
        `-- main.cpp                    (无变化)
```

---

### Sprint 3: 场景过渡与高级功能 (Part B) (6 天)

- **目标:** 实现 T2 场景 (P-2)、场景过渡 (P-1, P-3)，并完成课程要求的两个 Part B 高级特性 (P-4)：**阴影** 和**骨骼动画**。
    
- **交付物:** 一个功能完整的 Demo，满足 Part A 和 Part B 的核心要求。
    
- **每日任务:**
    
    - **Day 14: (核心) 场景 T2 (P-2) 与资源切换 (NFR-4)**
        
        - **任务:** 创建 `src/CSC8502_Assignment/Game/Scenes/Scene_T2_War.h`。
            
        - **任务:** `Scene_T2_War::Init()` **必须**加载 T2 资源（例如 `skybox_war/` (P-8), `ground_burnt.png` (P-0)）以确保 T2 的可识别性 (P-2)。
            
        - **任务 (关键 - NFR-4 已简化):** `Scene_T2_War` **必须**加载“废墟”模型。由于轨道 B 和 C 现在都支持 `.gltf`，**严禁**在场景代码中使用 `#ifdef` 宏（见 NFR-4 修改）。代码应简化为：
            
            ```cpp
            // In Scene_T2_War.cpp
            // 此代码现在无需宏，可同时在轨道 B 和 C 下运行
            auto ruins = m_Factory->LoadMesh("Assets/Models/ruins.gltf");
            // m_SceneGraph->AddChild(new MeshNode(ruins)); // P-6
            
            ```
            
        - **任务:** `SceneManager` **必须**被更新，以支持在 `Scene_T1_Peace` 和 `Scene_T2_War` 之间切换。
            
        - **验收:** `SceneManager` 可以成功切换和渲染 T1、T2 两个场景。轨道 B 成功加载 `ruins.gltf`。
            
    - **Day 15: (核心) 过渡效果 (P-1, P-3)**
        
        - **任务:** 创建 `Assets/Shaders/Shared/post_transition.frag` (NFR-6)，实现全屏过渡效果 (P-3)（例如，溶解、淡入淡出）。
            
        - **任务:** `PostProcessing.h` **必须**被修改，以使用此 `post_transition` 着色器，并能通过 `I_Shader::SetUniform` 接口接收一个 `float timer` (0.0 到 1.0)。
            
        - **任务:** `SceneManager` **必须**被修改：当检测到过渡触发键（例如 `I_Keyboard::KeyTriggered(IAL::KeyCode::T)`）时，启动一个计时器，并在计时器激活期间命令 `PostProcessing` 模块使用过渡效果。
            
        - **验收:** 按下 'T' 键，触发全屏过渡效果 (P-3)，视觉上从 T1 (P-2) 平滑过渡到 T2 (P-1)。
            
    - **Day 16: (高级) 高级特性 1 (阴影) (P-4)**
        
        - **任务:** 实现 `src/CSC8502_Assignment/Rendering/ShadowMap.h`。此模块**必须**依赖 `I_ResourceFactory::CreateShadowFBO()`（已在 Day 5 实现）。
            
        - **任务:** 创建 `Assets/Shaders/Shared/shadow.vert/frag` (NFR-6)，用于渲染深度到 FBO。
            
        - **任务:** `Renderer` **必须**添加一个新的渲染通道 `RenderSceneForShadowMap()`，该通道使用 `shadow` 着色器和 `ShadowMap` FBO。
            
        - **任务:** `Renderer` **必须**计算阴影视图/投影矩阵（**必须**使用 `nclgl::Matrix4`）。
            
        - **任务:** `Renderer` **必须**将阴影矩阵和 FBO 深度纹理（通过 `I_FrameBuffer::GetDepthTexture()`）传递给所有主场景着色器（`terrain.frag`, `water.frag` 等）。
            
        - **验收:** 场景中的物体（例如 `ruins.gltf`）可将实时动态阴影 (P-4) 投射到地形上。
            
    - **Day 17: (高级) 高级特性 2 (骨骼动画) IAL & B 轨 (P-4)**
        
        - **任务:** `IAL/I_ResourceFactory.h` **必须**添加 `LoadAnimatedMesh(path, animPathOrName)` 接口 (P-4)。
            
        - **任务 (轨道 B):** 实现 `B_Factory::LoadAnimatedMesh`。此实现**必须**：
            
            1. `#include "nclgl/Extra/GLTFLoader.h"`。
            2. 创建一个 `GLTFScene` 实例。
            3. 调用 `GLTFLoader::Load(path, scene)`。
            4. 从 `scene.meshes[0]` 获取 `nclgl::Mesh*`。
            5. 从 `scene.animations[0]` 获取 `nclgl::MeshAnimation*`。
            6. 将这两个指针包装在 `B_AnimatedMesh` 适配器中 (NFR-11.2)。
                
        - **任务 (NFR-13):** 实现 `B_AnimatedMesh::GetBoneTransforms()`。**必须**调用 `nclgl::MeshAnimation::GetJointData()`，获取 `const Matrix4*`，并将其转换为 `const std::vector<Matrix4>&`（可能需要一个 `std::vector` 成员变量来存储当前帧的变换）。
            
        - **验收：** 轨道 B 通过 `GLTFLoader` 成功加载 `.gltf`（含动画）并返回 `B_AnimatedMesh` 实例。
            
    - **Day 18: (高级) 高级特性 2 (骨骼动画) 集成 (P-4)**
        
        - **任务:** 创建 `Assets/Shaders/Shared/skinning.vert` (NFR-6)，实现 GPU 骨骼蒙皮（使用 `WEIGHTVALUE_BUFFER` 和 `WEIGHTINDEX_BUFFER`)。着色器**必须**接收一个 `uniform mat4 boneMatrices[MAX_BONES]` 数组。
            
        - **任务:** `Renderer` **必须**修改渲染循环：
            
            1.  `dynamic_cast` `SceneNode` 中的 `I_Mesh` 到 `I_AnimatedMesh`。
                
            2. 如果成功，调用 `animMesh->UpdateAnimation(dt)`。
				
                注：新 `TestProject/Renderer.cpp` 中的 `DrawAnimatedScene` 函数为此提供了一个比较好的实现参考，包括如何获取 `MeshAnimation`、计算当前帧、获取 `frameData` 并将其作为 `uniform mat4 joints[]` 传递给着色器，但不可复用TestProject内的代码。
                
            3. 通过 `animMesh->GetBoneTransforms()` (NFR-13) 获取骨骼矩阵（`const std::vector<Matrix4>&`）。
                
            4. 通过 `I_Shader::SetUniform` 将骨骼矩阵数组传递给 `skinning.vert` 着色器。
                
        - **任务:** `Scene_T1_Peace`（或 T2）应加载一个带骨骼动画的 `.gltf` 角色，并将其加入 `SceneGraph`（P-6）。
            
        - **验收:** (Track B) `nclgl` 驱动的骨骼动画 (P-4) 正常播放。
            
    - **Day 19: (核心) 相机轨迹 (P-5) 与最终集成**
        
        - **任务:** 在 `src/CSC8502_Assignment/Core/Camera.h` 中实现相机轨迹逻辑 (P-5)（例如，Catmull-Rom 样条）。轨迹点**必须**使用 `nclgl::Vector3`。
            
        - **任务:** `Application.cpp` **必须**在启动时将相机设置为 "Track" (轨迹) 模式。
            
        - **任务:** `Application.cpp` **必须**在更新循环中检测特定按键（例如 `I_Keyboard::KeyTriggered(IAL::KeyCode::F)`），以将相机切换到 "Free" (自由) 模式 (P-5)。
            
        - **验收:** 程序启动时相机自动飞行 (P-5)。按 'F' 键可切换到自由相机 (P-5)。所有功能 (P-0 至 P-8) 均已集成。
            

#### Sprint 3 完成后项目结构 (功能完整)

```
CSC8502_Framework/
|-- Assets/
|   |-- Heightmaps/ (无变化)
|   |-- Shaders/Shared/
|   |   |-- (T1 Shaders...)
|   |   |-- post_transition.frag  (已实现 P-3)
|   |   |-- shadow.vert/frag      (已实现 P-4)
|   |   `-- skinning.vert         (已实现 P-4)
|   |-- Models/
|   |   |-- character.gltf     (P-4 动画模型)
|   |   `-- ruins.gltf        (P-2 废墟模型)
|   `-- Textures/
|       |-- (T1 Textures...)
|       |-- ground_burnt.png
|       `-- skybox_war/           (6 张 .png)
|-- third_party/
|   `-- nclgl/
|       |-- Meshes/
|       |   |-- (旧版 .msh 文件, 项目不再依赖)
|       |-- (nclgl 库文件) ...
`-- src/
    |-- Engine/
    |   |-- IAL/ (无变化)
    |   `-- Implementations/NCLGL_Impl/
    |       |-- (Sprint 2 文件...)
    |       |-- B_Factory.h/.cpp        (已实现 LoadAnimatedMesh)
    |       `-- B_AnimatedMesh.h/.cpp   (已实现, 包装 Mesh/MeshAnimation NFR-13)
    `-- CSC8502_Assignment/
        |-- Core/
        |   |-- Application.h/.cpp      (已实现相机轨迹/自由切换 P-5)
        |   |-- Camera.h/.cpp         (已实现相机轨迹 P-5)
        |   |-- SceneManager.h/.cpp     (已实现 T1/T2 切换, 过渡 P-1, P-3)
        |   |-- (Light.h, SceneGraph.h ...)
        |-- Game/
        |   `-- Scenes/
        |       |-- Scene_T1_Peace.h/.cpp (已实现, 加载 P-4 动画)
        |       `-- Scene_T2_War.h/.cpp   (已实现, 加载 P-2 模型, 含 NFR-4 宏)
        |-- Rendering/
        |   |-- PostProcessing.h/.cpp   (已实现 P-3 过渡逻辑)
        |   |-- Renderer.h/.cpp         (已实现 P-4 阴影 和 P-4 动画管线)
        |   |-- ShadowMap.h/.cpp    (已实现 P-4)
        |   |-- (Skybox.h, Water.h ...)
        `-- main.cpp                    (无变化)
```

---

### Sprint 4: 交付物与轨道 B 冻结 (3 天)

- **目标:** 冻结功能 (NFR-14)，确保项目（轨道 B）稳定运行 (NFR-5)，并准备所有必要的交付物（文档、Zip 包）以满足课程提交要求。
    
- **交付物:** 一个符合 `8502.pdf` 交付要求的、已提交到 NESS 的 `.zip` 文件。
    
- **每日任务:**
    
    - **Day 20: (集成) 功能冻结与轨道 B 调试 (NFR-5)**
        
        - **任务:** 冻结所有新功能开发。
            
        - **任务:** **仅**在轨道 B（即注释 `NCL_USE_CUSTOM_IMPL`）下进行端到端测试。
            
        - **任务:** 确保 T1 -> 过渡 (P-3) -> T2 (P-2) 的完整流程稳定。
            
        - **任务:** 确保相机轨迹 (P-5) 和按键自由切换 (P-5) 功能正常。
            
        - **任务:** 确保两个高级特性（P-4）（阴影和骨骼动画）在场景中同时存在且**不会**导致渲染崩溃或严重性能问题 (NFR-5)。
            
        - **任务:** 在 Lab PC（或同等规格）上测试性能，确保稳定在 60fps。
            
        - **验收:** 轨道 B 版本稳定运行，满足所有核心 AC (验收标准)。
            
    - **Day 21: (交付) 视频与截图**
        
        - **任务:** 编写最终的相机轨迹 脚本，以展示所有已实现的功能（T1, T2, 过渡 P-3, 场景图 P-6, 光照 P-7, 天空盒 P-8, 阴影 P-4, 动画 P-4）。
            
        - **任务:** 录制高质量的演示视频。
            
        - **任务:** 剪辑视频，确保清晰展示了所有核心和高级功能。
            
        - **任务:** 将视频上传到 YouTube 并获取链接。
            
        - **任务:** 截取至少四张有意义的、展示不同特性的截图。
            
        - **验收:** YouTube 视频链接有效。截图准备完毕。
            
    - **Day 22: (交付) 文档与打包**
        
        - **任务:** 编写交付文档（.pdf 或 .md），包含：
            
            - 四张截图及描述。
                
            - YouTube 视频链接。
                
            - 键鼠操作列表（例如“T 键 - 触发过渡”，“F 键 - 切换自由相机”）。
                
            - 对所用高级特性的简要技术说明（阴影贴图、骨骼动画）。
                
        - **任务:** 清理 Visual Studio 解决方案 (NFR-5)。**必须**删除 `.vs/`, `.git/`, `x64/` (Build) 等文件夹。
            
        - **任务:** 将项目（源代码, VS 解决方案, `Assets/` 文件夹, `third_party/` 文件夹）和文档打包为**单个 .zip 文件**。
            
        - **任务:** 在 NESS 截止日期（11 月 14 日 16:00） 前提交 .zip 文件。
            
        - **验收:** 最终的 .zip 文件已成功提交。
            

#### Sprint 4 完成后项目结构 (最终交付)

```
(与 Sprint 3 结构相同，但已移除 .vs, .git, x64/ 等构建产物)
(根目录包含 交付文档.pdf)
```
### 回退与应急策略

- 一键回退到“直通渲染”：保留场景渲染到默认帧缓冲；后期模块置为直通，阴影关闭。
    
- 一键禁用所有自定义采样状态：恢复为双线性+Clamp，以排查采样问题。
    
- 资源最小集验证：仅加载天穹与一个网格，验证 FBO/纹理链路；通过后再逐步恢复全部资源。
    
- 日志强制开启：在空 UI 情况下以日志替代观测，问题定位后再关闭。

## 6. 最终架构依赖图 (接口驱动模型)

此图表总结了本计划的最终架构。它展示了一个由 `nclgl` 数学库 提供“通用数学语言”（NFR-2），由 `IAL` 纯虚接口层隔离所有“系统服务”（NFR-1）的、职责清晰的架构。

此架构承认一个必要的耦合点（NFR-9），它是架构切换所必需的：

1. **服务注入 (NFR-9):** `main.cpp` 依赖 `Implementations/` 来实例化 `Factory` 和 `WindowSystem`。
    
2. **资源选择 (NFR-4):** `Game/Scenes/` **不再**依赖宏，统一加载 `.gltf` 资源。
    

Plaintext

```
.================================================================================================================.
|                                   BUILD SYSTEM (VS2022 - 职责简化)                                          |
|                                (编译并链接 *所有* 目标: nclgl, Custom, Engine, CSC8502_Assignment)                  |
'================================================================================================================'
                                                   |
                                                   v
.----------------------------------------------------------------------------------------------------------------.
|                                   EXECUTABLE: CSC8502_Assignment (src/CSC8502_Assignment/)                    |
| .------------------------------------------------. .-------------------------------------------------------. |
| |   src/CSC8502_Assignment/main.cpp (NFR-9 注入点) | |   src/CSC8502_Assignment/Game/Scenes/ (NFR-4 资源选择) | |
| |                                                | |                                                       | |
| | #include "IAL/I_WindowSystem.h"                | | // (NFR-4: 此层不再需要宏)        | |
| | #include "IAL/I_ResourceFactory.h"             | |                                                       | |
| |                                                | | // 统一加载 .gltf 资源
| | #ifdef NCL_USE_CUSTOM_IMPL                     | | m_Factory->LoadMesh(".../ruins.gltf");                | |
| |   #include "Implementations/Custom_Impl/..."   | | m_Factory->LoadAnimatedMesh(".../character.gltf");    | |
| |   windowSystem = make_shared<C_WindowSystem>();| |                                                       | |
| | #else                                          | | (依赖 IAL/I_ResourceFactory 接口)                       | |
| |   #include "Implementations/NCLGL_Impl/..."    | |                                                       | |
| |   windowSystem = make_shared<B_WindowSystem>();| '-------------------------------------------------------' |
| | #endif                                         | | .-----------------------------------------------------. |
| |                                                | | | Core/Application.cpp (依赖 I_WindowSystem, I_Factory) | |
| | Application app(windowSystem, ...);            | | | Rendering/Renderer.cpp (依赖 I_Factory, I_Shader 等)  | |
| '------------------------------------------------' | | | Core/SceneGraph.cpp (P-6) (依赖 I_Mesh, nclgl::Matrix4) | |
|                                                    | | (NFR-1: 严禁 nclgl/Mesh.h, Window.h)      | |
|                                                    | | (NFR-2: 仅 #include "IAL/" 和 "nclgl/Vector3.h" 等) | |
|                                                    | '-----------------------------------------------------' |
|                                                    |                       | (仅依赖)                          |
|                                                    |                       v                                 |
| .------------------------------------------------------------------------------------------------------------. |
| |                                     LIBRARY: Engine (src/Engine/)                                          | |
| | .--------------------------------------------------------------------------------------------------------. | |
| | | IAL/ (纯虚接口层)                                                                                       | |
| | | I_Mesh.h, I_Shader.h, I_ResourceFactory.h                                                              | |
| | | I_WindowSystem.h, I_InputDevice.h (含 IAL::KeyCode 枚举)                                                  | |
| | | (接口签名 #include "nclgl/Vector3.h")                                        | |
| | '--------------------------------------------------------------------------------------------------------' | |
| | .---------------------------------------------------. .--------------------------------------------------. | |
| | | Implementations/NCLGL_Impl/ (轨道 B)              | | Implementations/Custom_Impl/ (轨道 C)            | |
| | | B_Factory.cpp (#include "nclgl/Mesh.h")           | | C_Factory.cpp (#include "Custom/C_Mesh.h")     | |
| | | B_WindowSystem.cpp (#include "nclgl/Window.h")    | | C_WindowSystem.cpp (#include "Custom/C_Window.h")| |
| | '---------------------------------------------------' '--------------------------------------------------' | |
| |                        |                                                      |                          | |
| |                        | (依赖)                                                 | (依赖)                     | |
| |                        v                                                      v                          | |
| | .---------------------------------------------------. .--------------------------------------------------. | |
| | | LIBRARY: nclgl (third_party/nclgl/)               | | LIBRARY: Custom (src/Engine/Custom/)             | |
| | |                                                   | |                                                  | |
| | | [ Vector3.h, Matrix4.h ] (NFR-2 通用数学) <----------' | (依赖 nclgl 数学库)                               | |
| | | [ Mesh.h, Window.h ] (NFR-11 系统实现)           | | [ C_Mesh.h, C_Window.h, C_GltfLoader.h ] (自研) | |
| | '---------------------------------------------------' '--------------------------------------------------' | |
| '----------------------------------------------------------------------------------------------------------------' |
'================================================================================================================'
```



## 7. 最终的项目文件结构

```cpp
CSC8502_Framework/
|
|-- CMakeLists.txt              // (可选：或使用 VS2022 解决方案 .sln)
|
|-- Assets/                     // (NFR-6: 共享资源)
|   |-- Fonts/
|   |   `-- Inter-Regular.ttf   // (轨道 C 自研 UI 使用)
|   |-- Heightmaps/
|   |   `-- terrain.png
|   |-- Models/
|   |   |-- character.gltf      // (P-4: <ins>轨道 B 和 C 共享的</ins> 动画模型, NFR-12)
|   |   `-- ruins.gltf          // (P-2: <ins>轨道 B 和 C 共享的</ins> 模型, NFR-12)
|   |-- Shaders/Shared/
|   |   |-- basic.frag
|   |   |-- basic.vert
|   |   |-- post_transition.frag// (P-3: 过渡效果)
|   |   |-- shadow.frag         // (P-4: 阴影)
|   |   |-- shadow.vert
|   |   |-- skinning.vert       // (P-4: 骨骼动画)
|   |   |-- skybox.frag
|   |   |-- skybox.vert
|   |   |-- terrain.frag        // (P-7: Blinn-Phong 光照)
|   |   |-- terrain.vert
|   |   |-- ui.frag             // (轨道 C 自研 UI)
|   |   |-- ui.vert
|   |   `-- water.frag
|   `-- Textures/
|       |-- ground_burnt.png
|       |-- water_normal.png
|       |-- skybox_peace/       // (6 张 .png)
|       `-- skybox_war/         // (6 张 .png)
|
|-- third_party/
|   |-- tinygltf/               // (轨道 C .gltf 加载器, NFR-12)
|   `-- nclgl/                  // (学校提供的代码库)
|       |
|       |-- Meshes/
|       |
|       |-- Extra/ // (NFR-11: nclgl 内置的 GLTF 加载器)</ins>
|       |       |-- GLTFLoader.h/.cpp</ins> > 
|       |-- Matrix4.h/.cpp      // (NFR-2: 通用数学库, Demo 层可 #include)
|       |-- Mesh.h/.cpp         // (NFR-1: 系统库, Demo 层严禁 #include)
|       |-- MeshAnimation.h/.cpp// (NFR-1: 系统库, Demo 层严禁 #include)
|       |-- OGLRenderer.h/.cpp  // (NFR-1: 系统库, Demo 层严禁 #include)
|       |-- Quaternion.h/.cpp   // (NFR-2: 通用数学库, Demo 层可 #include)
|       |-- Shader.h/.cpp       // (NFR-1: 系统库, Demo 层严禁 #include)
|       |-- Vector3.h           // (NFR-2: 通用数学库, Demo 层可 #include)
|       |-- Window.h/.cpp       // (NFR-1: 系统库, Demo 层严禁 #include)
|       |-- Keyboard.h/.cpp     // (NFR-1: 系统库, Demo 层严禁 #include)
|       `-- Mouse.h/.cpp        // (NFR-1: 系统库, Demo 层严禁 #include)
|
`-- src/
    |
    |-- Engine/                 // (引擎库 - 核心抽象层)
    |   |
    |   |-- IAL/                // (NFR-9: 纯虚接口层)
    |   |   |-- I_WindowSystem.h    // (抽象 Window+OGLRenderer)
    |   |   |-- I_InputDevice.h     // (抽象 Keyboard+Mouse, 含 IAL::KeyCode)
    |   |   |-- I_GameTimer.h       // (抽象 GameTimer)
    |   |   |-- I_AnimatedMesh.h
    |   |   |-- I_DebugUI.h
    |   |   |-- I_FrameBuffer.h
    |   |   |-- I_Heightmap.h
    |   |   |-- I_Mesh.h
    |   |   |-- I_ResourceFactory.h // (核心服务接口)
    |   |   |-- I_Shader.h
    |   |   `-- I_Texture.h
    |   |
    |   |-- Custom/             // (轨道 C: 自研功能实现) [NFR-14: 交付后目标]
    |   |   |-- Core/
    |   |   |   |-- C_WindowSystem.h/.cpp
    |   |   |   `-- C_InputDevice.h/.cpp
    |   |   |-- Graphics/
    |   |   |   |-- C_AnimatedMesh.h/.cpp, C_Animation.h/.cpp, C_Skeleton.h/.cpp
    |   |   |   |-- C_FrameBuffer.h/.cpp, C_Heightmap.h/.cpp, C_Mesh.h/.cpp
    |   |   |   |-- C_Shader.h/.cpp, C_Texture.h/.cpp
    |   |   |-- Loaders/
    |   |   |   `-- C_GltfLoader.h/.cpp // (NFR-12: 自研 gltf 加载器)
    |   |   `-- UI/
    |   |       `-- C_DebugUI.h/.cpp    // (P-5: 自研 IMGUI 或 ImGui 包装)
    |   |
    |   `-- Implementations/    // (IAL 接口的实现 "胶水层")
    |       |
    |       |-- Custom_Impl/    // (轨道 C "胶水层") [NFR-14: 交付后目标]
    |       |   |-- C_Factory.h/.cpp    // (创建 Engine/Custom/ 中的实例)
    |       |   `-- (轨道 C 的 IAL 实现可移至 Engine/Custom/ 中)
    |       |
    |       `-- NCLGL_Impl/     // (轨道 B "胶水层" - NCLGL 包装器) [NFR-14: 核心交付物]
    |           |-- B_WindowSystem.h/.cpp // (高风险包装 nclgl::Window 和 OGLRenderer, NFR-11.4)
    |           |-- B_InputDevice.h/.cpp  // (包装 nclgl::Keyboard 和 Mouse)
    |           |-- B_GameTimer.h/.cpp    // (包装 nclgl::GameTimer)
    |           |-- B_AnimatedMesh.h/.cpp // (包装 nclgl::Mesh/MeshAnimation)
    |           |-- B_DebugUI_Null.h/.cpp // (P-5: 空实现, NFR-11.3)
    |           |-- B_Factory.h/.cpp    // (创建 B_ 轨道实例)
    |           |-- B_FrameBuffer.h/.cpp  // (自研 FBO, NFR-11.3)
    |           |-- B_Heightmap.h/.cpp  // (png 加载器, 包装 nclgl::Mesh)
    |           |-- B_Mesh.h/.cpp       // (包装 nclgl::Mesh)
    |           |-- B_Shader.h/.cpp     // (包装 nclgl::Shader)
    |           `-- B_Texture.h/.cpp    // (包装 nclgl::OGLTexture)
    |
    `-- CSC8502_Assignment/           // (可执行文件 - 核心应用层)
        |                       // (NFR-2: 只依赖 IAL/ 和 nclgl 数学库)
        |
        |-- Core/
        |   |-- Application.h/.cpp  // (接收 IAL 接口, 包含主循环)
        |   |-- Camera.h/.cpp       // (P-5: 仅使用 nclgl 数学库)
        |   |-- Light.h             // (仅使用 nclgl::Vector3/4)
        |   |-- SceneManager.h/.cpp // (管理 SceneGraph 实例)
        |   `-- SceneGraph.h/.cpp   // (P-6: 自研场景图节点)
        |
        |-- Game/
        |   `-- Scenes/
        |       |-- Scene_T1_Peace.h/.cpp // (P-2, 包含 NFR-4 宏)
        |       `-- Scene_T2_War.h/.cpp   // (P-2, 包含 NFR-4 宏)
        |
        |-- Rendering/
        |   |-- PostProcessing.h/.cpp // (P-3: 依赖 I_FBO, I_Mesh)
        |   |-- Renderer.h/.cpp     // (核心渲染器, 依赖所有 IAL 接口)
        |   |-- ShadowMap.h/.cpp    // (P-4: 依赖 I_FBO)
        |   |-- Skybox.h/.cpp       // (P-8)
        |   `-- Water.h/.cpp        // (P-0)
        |
        `-- main.cpp                // (NFR-9: 唯一的依赖注入点)
                                    // (包含 #ifdef NCL_USE_CUSTOM_IMPL 宏切换)
```

## 8. 项目验收标准

此章节定义了项目（特别是用于提交的轨道 B NFR-14）的“完成”标准。所有标准均基于课程大纲 和本计划的功能性需求（Section 2）。

| **ID**           | **需求**              | **验收标准 (Acceptance Criteria)**                                                                                                                                                                                                                                                                                                |
| ---------------- | ------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Part A: 核心功能** |                     |                                                                                                                                                                                                                                                                                                                               |
| AC-P0            | 基础场景 (P-0)          | **测试：** 启动 `Scene_T1_Peace`（和平场景）。<br><br>  <br>  <br><br>**检查：** 场景必须包含一个使用 `.png` 高度图渲染的地形 (P-0)，一个程序化生成的水面 (P-0)，以及一个立方体贴图天空盒 (P-8)。                                                                                                                                                                                       |
| AC-P1            | 场景过渡 (P-1)          | **测试：** 在 T1 场景中，按下 `IAL::KeyCode::T` 键。<br><br>  <br>  <br><br>**检查：** 必须触发一个平滑的过渡 (P-1)，最终显示 T2 场景。                                                                                                                                                                                                                         |
| AC-P2            | 场景识别性 (P-2)         | **测试：** 对比 T1 和 T2 场景。<br><br>  <br>  <br><br>**检查：** T2 场景必须可被清晰地识别为 T1 的“不同时间版本” (P-2)。这必须通过至少三种视觉变化来体现（例如：不同的天空盒、不同的地形纹理、添加/移除/替换了关键模型如 `ruins.gltf`）。                                                                                                                                                                     |
| AC-P3            | 过渡效果 (P-3)          | **测试：** 触发 AC-P1 的过渡。<br><br>  <br>  <br><br>**检查：** 过渡**必须**通过一个全屏后期处理着色器来实现 (P-3)（例如溶解、淡入淡出），而不是简单的摄像机切换。                                                                                                                                                                                                                   |
| AC-P5            | 相机控制 (P-5)          | **测试 1：** 启动应用程序。<br><br>  <br>  <br><br>**检查 1：** 相机必须自动沿着预设的轨迹（Track）飞行 (P-5)。<br><br>  <br>  <br><br>**测试 2：** 按下 `IAL::KeyCode::F` 键。<br><br>  <br>  <br><br>**检查 2：** 相机必须切换到“自由”模式，允许通过 `IAL` 抽象的键鼠（WASD/Mouse）进行完全控制 (P-5)。                                                                                            |
| AC-P6            | 场景图 (P-6)           | **测试：** 代码审查 `Renderer.cpp` 的 `RenderScene()` 方法。<br><br>  <br>  <br><br>**检查：** 渲染循环**必须**遍历一个 `SceneGraph` (P-6)（一个树状结构，可处理子节点变换），而不是一个扁平的 `std::vector<Mesh*>` 列表。                                                                                                                                                         |
| AC-P7            | 基础光照 (P-7)          | **测试：** 观察 T1/T2 场景中的地形和模型。<br><br>  <br>  <br><br>**检查：** 物体光照**必须**正确计算了环境光、漫反射光和高光（Blinn-Phong）(P-7)。                                                                                                                                                                                                                      |
| AC-P8            | 环境映射 (P-8)          | **测试：** 观察 T1 场景（特别是水面）。<br><br>  <br>  <br><br>**检查：** 天空盒**必须**被正确渲染 (P-8)，并且（如果时间允许）水面应使用该天空盒进行环境映射。                                                                                                                                                                                                                       |
| **Part B: 高级功能** |                     |                                                                                                                                                                                                                                                                                                                               |
| AC-P4.1          | 高级：阴影 (P-4)         | **测试：** 观察 T1/T2 场景。<br><br>  <br>  <br><br>**检查：** **必须**实现基于动态方向光（太阳）的实时阴影贴图 (P-4)。至少一个静态物体（例如 `ruins.gltf`）和/或一个动态物体（`character.gltf`）**必须**能将阴影投射到地形（`Heightmap`）上。                                                                                                                                                       |
| AC-P4.2          | 高级：骨骼动画 (P-4)       | **测试：** 观察 T1/T2 场景。<br><br>  <br>  <br><br>**检查：** **必须**加载至少一个带骨骼动画的模型（轨道 B 中为<del> `character.msh` 和 `character.anm`</del> <ins>一个 `.gltf` 文件，例如 `character.gltf`</ins>）。动画 (P-4) 必须在场景中正确播放。                                                                                                                              |
| AC-P5.3          | 高级：UI (P-5)         | **测试：** （仅轨道 C）启动应用程序。<br><br>  <br>  <br><br>**检查：** 必须显示一个调试 UI (P-5)，允许实时调整 AC-P7 中的光照参数。轨道 B 的 `B_DebugUI_Null` (NFR-11.3) 被接受为空实现。                                                                                                                                                                                       |
| **架构与交付**        |                     |                                                                                                                                                                                                                                                                                                                               |
| AC-NFR           | 双轨切换 (NFR-4, NFR-9) | **测试 1：** 在 `main.cpp` 中**注释** `NCL_USE_CUSTOM_IMPL` 宏并编译。<br><br>  <br>  <br><br>**检查 1：** 程序必须在轨道 B (nclgl) [NFR-14] 下成功运行，满足上述所有 P-x 和 AC-P4.x 验收标准。<br><br>  <br>  <br><br>**测试 2：** 在 `main.cpp` 中**取消注释** `NCL_USE_CUSTOM_IMPL` 宏并编译。<br><br>  <br>  <br><br>**检查 2：** 程序必须在轨道 C (自研) [NFR-14] 下成功运行（允许功能降级，但核心管线必须工作）。 |
| AC-NFR-1         | **系统解耦 (NFR-1)**    | **测试：** 对 `src/CSC8502_Assignment/` 目录（`main.cpp` 和 `Game/Scenes/` 除外）下的所有 `.h` 和 `.cpp` 文件进行代码审查。<br><br>  <br>  <br><br>**检查：** **严禁**出现 `#include "nclgl/Mesh.h"`、`#include "nclgl/Shader.h"`、`#include "nclgl/Window.h"` 或 `#include "nclgl/OGLRenderer.h"` (NFR-1)。                                                      |
| AC-NFR-2         | **依赖抽象 (NFR-2)**    | **测试：** 审查 `AC-NFR-1` 中相同的文件。<br><br>  <br>  <br><br>**检查：** 所有系统级依赖**必须**指向 `Engine/IAL/` 目录下的接口（例如 `#include "IAL/I_Mesh.h"`），并且**允许**包含 `nclgl/` 目录下的数学库（例如 `#include "nclgl/Vector3.h"`） (NFR-2)。                                                                                                                         |
| AC-NFR-11.3      | **FBO 自研 (NFR-11)** | **测试：** 在轨道 B 下运行，启用阴影（AC-P4.1）和后处理（AC-P3）。<br><br>  <br>  <br><br>**检查：** `B_FrameBuffer` 实例**必须**成功创建、绑定并渲染，证明自研的 FBO 功能 (NFR-11.3) 在 `nclgl` 上下文中有效。                                                                                                                                                                       |
| AC-NFR-11.4      | **输入法包装 (NFR-11)**  | **测试：** 在 `B_WindowSystem::Init` 之后（或 `GetKeyboard` 中）设置断点。<br><br>  <br>  <br><br>**检查：** `B_Keyboard` 适配器**必须**包装由 `nclgl::Window` 自动创建的 `static Window::keyboard` 实例，**严禁** `new` 一个新的 `nclgl::Keyboard`。`Mouse` 同理 (NFR-11.4)。                                                                                            |
| AC-NFR-11.TEX    | 纹理生命周期与状态一致性        | 测试：开启资源审计日志运行一个场景，加载至少三类纹理（地形、天空盒、后期中间贴图）。<br><br>检查：1) 纹理对象的创建与释放次数与场景切换次数匹配，无重复销毁；2) 采样状态（滤波/包裹/各向异性）在任意两次渲染比较时保持一致；3) 纹理与 FBO 附件来源不同但生命周期语义一致。                                                                                                                                                                             |
| AC-NFR-11.PP     | 后期链路与色域一致性          | 测试：在轨道 B 下运行后期直通，记录 FBO 附件格式与默认帧缓冲格式。  <br>检查：1) FBO 完整性为“完整”；2) 直通输出与默认清屏色一致（无伽马偏差）；3) 切换一套不同分辨率的 FBO 后，后期输出无拉伸与锯齿异常。                                                                                                                                                                                                        |
| AC-NFR5          | 性能 (NFR-5)          | **测试：** 在 Lab PC 上以 Fullscreen 模式运行**轨道 B** 版本 (NFR-14)。<br><br>  <br>  <br><br>**检查：** 演示**必须**稳定运行在 60fps (NFR-5)。                                                                                                                                                                                                          |
| AC-DEL           | 交付物 (Sprint 4)      | **测试：** 检查 NESS 提交的 `.zip` 文件。<br><br>  <br>  <br><br>**检查：** 必须包含：1. 完整的、已清理的 VS 解决方案和源代码 (NFR-11)。 2. 包含截图、YouTube 链接和操作说明的文档 (P-5)。                                                                                                                                                                                        |
